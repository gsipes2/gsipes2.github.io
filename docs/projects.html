<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Projects – gsipes2.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-b651517ce65839d647a86e2780455cfb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-0774fc528949661fb60d8774007a227f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">gsipes2.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./tutorials.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./projects.html" aria-current="page"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#evaluation-of-adapted-exercise-modes" id="toc-evaluation-of-adapted-exercise-modes" class="nav-link active" data-scroll-target="#evaluation-of-adapted-exercise-modes">Evaluation of Adapted Exercise Modes</a></li>
  <li><a href="#smartwatch-based-wheelchair-propulsion-monitoring" id="toc-smartwatch-based-wheelchair-propulsion-monitoring" class="nav-link" data-scroll-target="#smartwatch-based-wheelchair-propulsion-monitoring">Smartwatch-Based Wheelchair Propulsion Monitoring</a></li>
  <li><a href="#handcycling-force-prediction-from-wearable-sensors" id="toc-handcycling-force-prediction-from-wearable-sensors" class="nav-link" data-scroll-target="#handcycling-force-prediction-from-wearable-sensors">Handcycling Force Prediction from Wearable Sensors</a></li>
  <li><a href="#flexible-multi-camera-markerless-motion-capture-pipeline" id="toc-flexible-multi-camera-markerless-motion-capture-pipeline" class="nav-link" data-scroll-target="#flexible-multi-camera-markerless-motion-capture-pipeline">Flexible Multi-Camera Markerless Motion Capture Pipeline</a></li>
  <li><a href="#machine-learning-for-equine-ground-reaction-force-estimation" id="toc-machine-learning-for-equine-ground-reaction-force-estimation" class="nav-link" data-scroll-target="#machine-learning-for-equine-ground-reaction-force-estimation">Machine Learning for Equine Ground Reaction Force Estimation</a></li>
  <li><a href="#finite-element-analysis-of-equine-bone-fracture-risk" id="toc-finite-element-analysis-of-equine-bone-fracture-risk" class="nav-link" data-scroll-target="#finite-element-analysis-of-equine-bone-fracture-risk">Finite Element Analysis of Equine Bone Fracture Risk</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Projects</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="evaluation-of-adapted-exercise-modes" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-of-adapted-exercise-modes">Evaluation of Adapted Exercise Modes</h2>
<!-- **Keywords:** `Musculoskeletal Modeling` `OpenSim` `Wearable Sensors` `Community-Based Research` -->
<ul>
<li><p>Conducting community-based evaluations of adapted exercise modes using wearable sensors and musculoskeletal modeling to assess musculoskeletal safety and participant enjoyment.</p></li>
<li><p>Data collection combines graded exercise testing on a custom wheelchair ergometer (following ACSM protocols) with personalized workouts performed in community settings.</p></li>
<li><p>The study recruits participants across a broad age range and varied activity backgrounds (athletic and non‑athletic) to improve generalizability.</p></li>
<li><p>Primary outcomes include shoulder loading and propulsion metrics derived from musculoskeletal modeling and sensor data, alongside self-reported enjoyment to compare exercise modes.</p></li>
<li><p><strong>Presentation:</strong> <em>Evaluation of propulsion biomechanics during exercise with a suspended-wheel everyday wheelchair</em> (American Society of Biomechanics Annual Meeting, 2024)</p></li>
</ul>
<hr>
</section>
<section id="smartwatch-based-wheelchair-propulsion-monitoring" class="level2">
<h2 class="anchored" data-anchor-id="smartwatch-based-wheelchair-propulsion-monitoring">Smartwatch-Based Wheelchair Propulsion Monitoring</h2>
<!-- **Keywords:** `Machine Learning` `Wearable Sensors` `Smartwatch` -->
<p>Developing a novel method to predict manual wheelchair propulsion kinetics using only smartwatch sensor data. This work addresses the limitations of gold-standard devices (e.g., the SMARTWheel), which are no longer widely available and are restricted to laboratory use. The system aims to predict all six components of hand reaction loads (three forces and three moments) and to enable calculation of common wheelchair propulsion metrics. This pilot study is evaluating whether consumer-grade wearables can provide accurate, field-deployable measures of biomechanical loading to support injury prevention and rehabilitation for manual wheelchair users.</p>
<ul>
<li><strong>Presentation:</strong> <em>Predicting manual wheelchair propulsion kinetics using smartwatch data: a pilot study</em> (MRC Annual Symposium, Washington University in St.&nbsp;Louis, 2025)</li>
</ul>
<!-- * **Innovation:** First system to enable field-based monitoring of wheelchair propulsion biomechanics using consumer wearable technology
* **Impact:** Enables long-term monitoring of musculoskeletal safety during exercise interventions for wheelchair users
* **Technical Stack:** Python, TensorFlow, inertial motion capture, OpenSim musculoskeletal modeling -->
<hr>
</section>
<section id="handcycling-force-prediction-from-wearable-sensors" class="level2">
<h2 class="anchored" data-anchor-id="handcycling-force-prediction-from-wearable-sensors">Handcycling Force Prediction from Wearable Sensors</h2>
<!-- **Keywords:** `Machine Learning` `Temporal Convolutional Networks` `Biomechanics` `Rehabilitation Engineering` -->
<p>Investigated the feasibility of predicting continuous hand reaction forces during handcycling using only arm segment kinematics. This work compared multiple machine learning architectures including temporal convolutional networks (TCN), residual networks, and ensemble methods against traditional statistical approaches. The TCN model achieved correlation coefficients up to r=0.97 for in-plane forces, enabling replacement of instrumented crank handles in future studies.</p>
<ul>
<li><p><strong>Publication:</strong> <em>Kinematics-Based Predictions of External Loads during Handcycling</em> (Sensors, 2024)</p></li>
<li><p><strong>Presentation:</strong> <em>Estimating hand reaction forces from arm segment accelerations during handcycle propulsion using machine learning</em> (Congress of the International Society of Biomechanics, 2023)</p></li>
</ul>
<!-- * **Technical Achievement:** Demonstrated that machine learning models can leverage temporal dependencies in kinematic data to accurately predict kinetics -->
<!-- * **Applications:** Enables power monitoring and musculoskeletal safety assessment during handcycling exercise outside laboratory settings -->
<hr>
</section>
<section id="flexible-multi-camera-markerless-motion-capture-pipeline" class="level2">
<h2 class="anchored" data-anchor-id="flexible-multi-camera-markerless-motion-capture-pipeline">Flexible Multi-Camera Markerless Motion Capture Pipeline</h2>
<!-- **Keywords:** `Computer Vision` `DeepLabCut` `OpenCV` `Photogrammetry` `Multi-view Geometry` `Python` -->
<p>Developing a scalable motion capture system that works with any N≥2 consumer cameras to achieve research-grade 3D motion tracking. The complete pipeline includes:</p>
<ul>
<li><strong>Camera Calibration:</strong> Estimating intrinsic parameters for each camera using Zhang’s method with planar calibration targets</li>
<li><strong>Lens Distortion Correction:</strong> Applying radial and tangential distortion models to correct image artifacts</li>
<li><strong>Camera Pose Estimation:</strong> Solving the Perspective-n-Point (PnP) problem to determine extrinsic camera parameters</li>
<li><strong>Keypoint Tracking:</strong> Using deep learning-based keypoint detection (DeepLabCut) to track anatomical landmarks across multiple views</li>
<li><strong>3D Reconstruction:</strong> Triangulating 2D keypoints into accurate 3D coordinates using multi-view geometric constraints</li>
</ul>
<!-- * **Technical Innovation:** Flexible pipeline that adapts to any camera configuration while maintaining high accuracy
* **Accessibility:** Eliminates dependency on expensive specialized equipment using consumer cameras and open-source software
* **Applications:** Biomechanics research, clinical movement analysis, sports performance tracking -->
<!-- ### Accessible Wheelchair Propulsion Monitoring from Smartwatch Data
**Keywords:** `Machine Learning` `Wearable Sensors` `Python` `Accessibility` `Biomechanics`
- Predicted wheelchair propulsion kinetics from smartwatch data to create an accessible tool for quantifying propulsion.
- This pilot study explores using consumer-grade wearable sensors to monitor biomechanical loads outside the lab, aiming to help reduce the risk of upper limb injuries in manual wheelchair users. -->
<!-- ### Low-Cost, Markerless Motion Capture Pipeline
**Keywords:** `Computer Vision` `DeepLabCut` `OpenCV` `Photogrammetry` `Open-Source`
- Developed an accessible markerless motion capture pipeline using low-cost cameras and open-source tools for photogrammetry and deep learning-based pose estimation.
- This system makes biomechanical analysis more accessible by eliminating the need for expensive, specialized motion capture equipment. -->
<hr>
</section>
<section id="machine-learning-for-equine-ground-reaction-force-estimation" class="level2">
<h2 class="anchored" data-anchor-id="machine-learning-for-equine-ground-reaction-force-estimation">Machine Learning for Equine Ground Reaction Force Estimation</h2>
<!-- **Keywords:** `Machine Learning` `Python` `Scikit-learn` `Equine Biomechanics` `Gait Analysis` -->
<ul>
<li><p>Estimated equine ground reaction forces using kinematic and anthropometric data with machine learning models.</p></li>
<li><p>Developed statistical approaches to predict loading during walking and trotting, providing non-invasive methods for veterinary biomechanical assessment.</p></li>
<li><p><strong>Publication:</strong> <em>Statistical approaches for estimating forelimb ground reaction forces in foals during walking and trotting</em> (Journal of Biomechanics, 2025 — Submitted)</p></li>
</ul>
<hr>
</section>
<section id="finite-element-analysis-of-equine-bone-fracture-risk" class="level2">
<h2 class="anchored" data-anchor-id="finite-element-analysis-of-equine-bone-fracture-risk">Finite Element Analysis of Equine Bone Fracture Risk</h2>
<!-- **Keywords:** `Finite Element Analysis` `Abaqus` `ImageJ` `Biomechanics` `Bone Mechanics` -->
<ul>
<li><p>Analyzed high fracture risk regions of equine bone using subject-specific finite element models.</p></li>
<li><p>Created detailed models from CT data to understand stress distribution in fracture-prone areas of the third metacarpal.</p></li>
<li><p><strong>Presentation:</strong> <em>Bone quality differences in fracture-prone regions of the equine third metacarpal</em> (Orthopaedic Research Society, 2021)</p></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>