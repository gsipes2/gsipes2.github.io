<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>balancesignalprocessingtutorial – gsipes2.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-b651517ce65839d647a86e2780455cfb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-0774fc528949661fb60d8774007a227f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">gsipes2.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../tutorials.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#force-plate-signal-processing-for-balance-analysis-a-practical-tutorial" id="toc-force-plate-signal-processing-for-balance-analysis-a-practical-tutorial" class="nav-link active" data-scroll-target="#force-plate-signal-processing-for-balance-analysis-a-practical-tutorial">Force-plate signal processing for balance analysis — a practical tutorial</a>
  <ul class="collapse">
  <li><a href="#environment-setup-what-this-cell-does-and-why-it-matters" id="toc-environment-setup-what-this-cell-does-and-why-it-matters" class="nav-link" data-scroll-target="#environment-setup-what-this-cell-does-and-why-it-matters">Environment setup — what this cell does and why it matters</a></li>
  <li><a href="#download-load-eoec-data-what-this-cell-does" id="toc-download-load-eoec-data-what-this-cell-does" class="nav-link" data-scroll-target="#download-load-eoec-data-what-this-cell-does">Download &amp; load EO/EC data (what this cell does)</a></li>
  <li><a href="#what-is-a-force-plate" id="toc-what-is-a-force-plate" class="nav-link" data-scroll-target="#what-is-a-force-plate">What is a force plate?</a></li>
  <li><a href="#what-it-measures-primary-signals" id="toc-what-it-measures-primary-signals" class="nav-link" data-scroll-target="#what-it-measures-primary-signals">What it measures (primary signals)</a></li>
  <li><a href="#typical-outputs-and-data-format" id="toc-typical-outputs-and-data-format" class="nav-link" data-scroll-target="#typical-outputs-and-data-format">Typical outputs and data format</a></li>
  <li><a href="#key-practical-notes-pitfalls" id="toc-key-practical-notes-pitfalls" class="nav-link" data-scroll-target="#key-practical-notes-pitfalls">Key practical notes / pitfalls</a></li>
  <li><a href="#typical-applications" id="toc-typical-applications" class="nav-link" data-scroll-target="#typical-applications">Typical applications</a></li>
  <li><a href="#lets-see-what-our-forceplate-data-looks-like" id="toc-lets-see-what-our-forceplate-data-looks-like" class="nav-link" data-scroll-target="#lets-see-what-our-forceplate-data-looks-like">Let’s see what our force‑plate data looks like</a></li>
  <li><a href="#plotting-helper-how-to-use-these-diagnostic-plots" id="toc-plotting-helper-how-to-use-these-diagnostic-plots" class="nav-link" data-scroll-target="#plotting-helper-how-to-use-these-diagnostic-plots">Plotting helper — how to use these diagnostic plots</a></li>
  <li><a href="#spectral-analysis-helper-interpretation-and-practical-use" id="toc-spectral-analysis-helper-interpretation-and-practical-use" class="nav-link" data-scroll-target="#spectral-analysis-helper-interpretation-and-practical-use">Spectral analysis helper — interpretation and practical use</a></li>
  <li><a href="#filtering-helper-summary-and-expected-behavior" id="toc-filtering-helper-summary-and-expected-behavior" class="nav-link" data-scroll-target="#filtering-helper-summary-and-expected-behavior">Filtering helper — summary and expected behavior</a></li>
  <li><a href="#synthetic-signal-demo-what-to-look-for" id="toc-synthetic-signal-demo-what-to-look-for" class="nav-link" data-scroll-target="#synthetic-signal-demo-what-to-look-for">Synthetic signal demo — what to look for</a></li>
  <li><a href="#interactive-slider-how-to-use-and-what-to-observe" id="toc-interactive-slider-how-to-use-and-what-to-observe" class="nav-link" data-scroll-target="#interactive-slider-how-to-use-and-what-to-observe">Interactive slider — how to use and what to observe</a></li>
  <li><a href="#choosing-a-cumulative-power-threshold" id="toc-choosing-a-cumulative-power-threshold" class="nav-link" data-scroll-target="#choosing-a-cumulative-power-threshold">Choosing a cumulative power threshold</a></li>
  <li><a href="#convert-measured-voltages-to-forces-and-moments" id="toc-convert-measured-voltages-to-forces-and-moments" class="nav-link" data-scroll-target="#convert-measured-voltages-to-forces-and-moments">Convert measured voltages to forces and moments</a></li>
  <li><a href="#filtering-and-selecting-cutoff-frequencies-practical-guide" id="toc-filtering-and-selecting-cutoff-frequencies-practical-guide" class="nav-link" data-scroll-target="#filtering-and-selecting-cutoff-frequencies-practical-guide">Filtering and selecting cutoff frequencies — practical guide</a></li>
  <li><a href="#center-of-pressure-cop-calculation-and-stabilogram-plotting" id="toc-center-of-pressure-cop-calculation-and-stabilogram-plotting" class="nav-link" data-scroll-target="#center-of-pressure-cop-calculation-and-stabilogram-plotting">Center of Pressure (CoP) — calculation and stabilogram plotting</a></li>
  <li><a href="#balance-metrics-definitions-computation-and-interpretation" id="toc-balance-metrics-definitions-computation-and-interpretation" class="nav-link" data-scroll-target="#balance-metrics-definitions-computation-and-interpretation">Balance metrics — definitions, computation, and interpretation</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://colab.research.google.com/github/gsipes2/gsipes2.github.io/blob/main/notebooks/BalanceSignalProcessingTutorial.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" class="img-fluid figure-img"></a></p>
<figcaption>Open in Colab</figcaption>
</figure>
</div>
<section id="force-plate-signal-processing-for-balance-analysis-a-practical-tutorial" class="level1">
<h1>Force-plate signal processing for balance analysis — a practical tutorial</h1>
<p>This notebook teaches the fundamentals of signal processing using a common biomechanics example: force‑plate data for postural/balance analysis. It is intended to give hands‑on experience with signal processing by converting raw force‑plate voltages into meaningful balance metrics (e.g., CoP stabilograms, excursion ranges, CoP speed).</p>
<p>Prerequisites - Basic Python experience (pandas, numpy, matplotlib). - Familiarity with time series concepts (sampling rate, basic plotting) is helpful but not required — the notebook introduces essential signal‑processing ideas as we go.</p>
<p>Learning objectives - Load and inspect force‑plate time series (voltages). - Convert voltages to forces/moments using a calibration matrix and amplifier settings. - Use power spectral density (PSD) to choose data‑driven low‑pass filter cutoffs (cumulative power). - Apply zero‑phase Butterworth filtering. - Compute Center of Pressure (CoP), visualize stabilograms, and calculate scalar sway metrics (AP/ML range, mean CoP speed, excursion statistics).</p>
<p>Notebook flow 1. Environment &amp; helper functions (imports, plotting, download). 2. Data loading and basic inspection. 3. Spectral methods to select filter cutoffs and filtering helpers. 4. Convert voltages → forces/moments and compute CoP. 5. Visualize stabilograms and compute balance metrics; compare conditions (e.g., eyes open vs closed).</p>
<p>Data note - Example files in this notebook use tandem‑stance (one foot in front of the other) balance tests under two conditions (eyes‑open vs eyes‑closed) to illustrate typical contrasts. Replace the example URLs/files with your own data as needed.</p>
<p>Reproducibility &amp; reporting reminders - Record sampling rate, filter design (type, order), and cutoff selection method when sharing results.</p>
<p>Takeaway: follow a data‑driven, visual workflow — check raw signals, inspect PSDs, choose cutoffs with diagnostics, apply zero‑phase filtering when possible, and document everything.</p>
<section id="environment-setup-what-this-cell-does-and-why-it-matters" class="level3">
<h3 class="anchored" data-anchor-id="environment-setup-what-this-cell-does-and-why-it-matters">Environment setup — what this cell does and why it matters</h3>
<p>This small section ensures the Python environment has the packages used in the notebook and documents why each is needed. Key points:</p>
<p>Notes - On Colab the cell uses <code>%pip install</code> so dependencies are available</p>
<p>Takeaway: Make sure imports succeed before continuing; the rest of the notebook assumes these packages are available.</p>
<div id="6609d175" class="cell" data-execution_count="74">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Environment setup (Colab-friendly)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install numpy pandas scipy matplotlib requests ipywidgets <span class="op">--</span>quiet</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard library imports</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os  <span class="co"># For interacting with the operating system (e.g., file paths)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> io  <span class="co"># For handling streams and file-like objects</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> io <span class="im">import</span> StringIO  <span class="co"># For working with string buffers as file-like objects</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Any, Dict, List, Optional, Sequence, Union</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Third-party library imports</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np  <span class="co"># For numerical computations and array operations</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd  <span class="co"># For data manipulation and analysis using DataFrames</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.signal <span class="im">import</span> welch, butter, filtfilt, lfilter  <span class="co"># For signal processing (spectral density, filtering)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt  <span class="co"># For creating plots and visualizations</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests  <span class="co"># For making HTTP requests</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ipywidgets  <span class="co"># For creating interactive widgets in Jupyter notebooks</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ipywidgets <span class="im">as</span> widgets  <span class="co"># IPython widgets with an alias for convenience</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> IPython.display  <span class="co"># For rendering rich outputs (e.g., images, HTML)</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>_LOGGER <span class="op">=</span> logging.getLogger(<span class="va">__name__</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Jupyter-specific magic commands</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Set default plot parameters settings</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'default'</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'axes.titlesize'</span>] <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'axes.labelsize'</span>] <span class="op">=</span> <span class="dv">14</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'xtick.labelsize'</span>] <span class="op">=</span> <span class="st">'large'</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'ytick.labelsize'</span>] <span class="op">=</span> <span class="st">'large'</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'font.family'</span>] <span class="op">=</span> <span class="st">'Sans'</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'mathtext.fontset'</span>] <span class="op">=</span> <span class="st">'stix'</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.figsize'</span>] <span class="op">=</span> <span class="dv">8</span>, <span class="dv">6</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.dpi'</span>] <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.autolayout'</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'axes.grid'</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Streaming download helper (same pattern as IntroductionImageProcessing.ipynb)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> download_file(url, save_path):</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Download a file via streaming and save to disk. Returns the save_path."""</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> requests.get(url, stream<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    r.raise_for_status()</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    os.makedirs(os.path.dirname(save_path), exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(save_path, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> chunk <span class="kw">in</span> r.iter_content(chunk_size<span class="op">=</span><span class="dv">8192</span>):</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> chunk:</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>                f.write(chunk)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> save_path</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage (replace with your Box static links):</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co"># download_file('https://uofi.box.com/shared/static/FILEID.txt', '/content/eo_data.txt')</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Note: you may need to restart the kernel to use updated packages.</code></pre>
</div>
</div>
</section>
<section id="download-load-eoec-data-what-this-cell-does" class="level3">
<h3 class="anchored" data-anchor-id="download-load-eoec-data-what-this-cell-does">Download &amp; load EO/EC data (what this cell does)</h3>
<ul>
<li>Downloads two example force‑plate text files (EO/EC) from the provided URLs and saves them to local paths (colab-friendly: <code>/content/eo_data.txt</code>, <code>/content/ec_data.txt</code>).</li>
<li>Reads the files into pandas DataFrames using <code>pd.read_csv(...)</code> with:
<ul>
<li><code>delimiter='\t'</code>, <code>skiprows=6</code>, and column names <code>['Time','VFx','VFy','VFz','VMx','VMy','VMz']</code>.</li>
</ul></li>
<li>Coerces all columns to numeric (<code>pd.to_numeric(..., errors='coerce')</code>) so non‑numeric tokens become NaN.</li>
<li>Prints the first rows of each DataFrame to allow a quick header/alignment check.</li>
</ul>
<p>Notes / things to check or change if using your own data - Replace EO_URL / EC_URL with your direct file links (Box direct‑download or other static URLs). - Adjust <code>skiprows</code>, <code>delimiter</code>, and <code>names</code> to match your file format if headers or metadata differ.</p>
<p>After running, inspect: - <code>df_EO.head()</code>, <code>df_EC.head()</code> for column alignment, - <code>df_EO.info()</code>, <code>df_EC.info()</code> for dtypes and NaNs, - how many NaNs were created; decide to interpolate, fill, or drop before spectral/filters. - Files are saved under <code>/content/</code> (Colab); change paths for a different environment.</p>
<div id="81749b9c" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>EO_URL <span class="op">=</span> <span class="st">'https://uofi.box.com/shared/static/elqg597eogilxkqc94kg1wjwfjzwtyzy.txt'</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>EC_URL <span class="op">=</span> <span class="st">'https://uofi.box.com/shared/static/0a1pbfhmtxadpstrw8cdd07ziz26tar2.txt'</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> download_file(url, save_path):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> requests.get(url, stream<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    r.raise_for_status()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(save_path, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> chunk <span class="kw">in</span> r.iter_content(chunk_size<span class="op">=</span><span class="dv">8192</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            f.write(chunk)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> save_path</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Local paths to save the downloaded files (Colab-friendly /content/)</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>eo_path <span class="op">=</span> <span class="st">'/content/eo_data.txt'</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>ec_path <span class="op">=</span> <span class="st">'/content/ec_data.txt'</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Download files (streaming) and then read with pandas</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>download_file(EO_URL, eo_path)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>download_file(EC_URL, ec_path)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Adjust these read_csv args to match your file format (delimiter, header rows, column names)</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> [<span class="st">'Time'</span>, <span class="st">'VFx'</span>, <span class="st">'VFy'</span>, <span class="st">'VFz'</span>, <span class="st">'VMx'</span>, <span class="st">'VMy'</span>, <span class="st">'VMz'</span>]</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Read files robustly and coerce numeric types</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>df_EO <span class="op">=</span> pd.read_csv(eo_path, delimiter<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>, skiprows<span class="op">=</span><span class="dv">6</span>, names<span class="op">=</span>cols, engine<span class="op">=</span><span class="st">'python'</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>df_EC <span class="op">=</span> pd.read_csv(ec_path, delimiter<span class="op">=</span><span class="st">'</span><span class="ch">\t</span><span class="st">'</span>, skiprows<span class="op">=</span><span class="dv">6</span>, names<span class="op">=</span>cols, engine<span class="op">=</span><span class="st">'python'</span>)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Ensure all columns are numeric where possible (non-numeric -&gt; NaN)</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df <span class="kw">in</span> (df_EO, df_EC):</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> cols:</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        df[c] <span class="op">=</span> pd.to_numeric(df[c], errors<span class="op">=</span><span class="st">'coerce'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Eyes Open Dataframe:

    Time       VFx       VFy       VFz       VMx       VMy       VMz
0  0.000  0.012344 -0.087344  2.551563 -1.753438  0.204531 -0.745938
1  0.001  0.014687 -0.088281  2.552812 -1.759375  0.201094 -0.749375
2  0.002  0.013281 -0.088281  2.553438 -1.759375  0.203437 -0.750938
3  0.003  0.015000 -0.088438  2.552188 -1.758125  0.199844 -0.752344
4  0.004  0.010156 -0.089844  2.551875 -1.761719  0.200937 -0.749531


Eyes Closed Dataframe:

    Time       VFx       VFy       VFz       VMx       VMy       VMz
0  0.000  0.001406 -0.084531  2.547188 -1.909531  0.104844 -0.735156
1  0.001  0.000625 -0.087656  2.549375 -1.912813  0.105313 -0.734844
2  0.002 -0.001250 -0.087656  2.547813 -1.913281  0.105625 -0.735938
3  0.003 -0.002188 -0.087031  2.546250 -1.908906  0.106094 -0.731250
4  0.004 -0.005469 -0.086406  2.549375 -1.909375  0.107813 -0.736875</code></pre>
</div>
</div>
</section>
<section id="what-is-a-force-plate" class="level3">
<h3 class="anchored" data-anchor-id="what-is-a-force-plate">What is a force plate?</h3>
<p>A force plate (force platform) is a rigid instrumented plate that measures the forces and moments exchanged between a subject (or object) and the ground. It converts mechanical loads on its sensing elements (usually strain gauges or load cells) into electrical signals that are recorded as time‑series. Force plates are widely used in biomechanics, gait analysis, balance/postural control, ergonomics, and sports science.</p>
</section>
<section id="what-it-measures-primary-signals" class="level3">
<h3 class="anchored" data-anchor-id="what-it-measures-primary-signals">What it measures (primary signals)</h3>
<ul>
<li>Forces along three orthogonal axes:
<ul>
<li>Fx, Fy — shear (horizontal) forces (medial–lateral, anterior–posterior)</li>
<li>Fz — vertical ground reaction force</li>
</ul></li>
<li>Moments about the same three axes:
<ul>
<li>Mx, My, Mz — moments/torques (N·m)</li>
</ul></li>
</ul>
<p>Many systems output raw voltages for the six channels (VFx, VFy, VFz, VMx, VMy, VMz) which must be converted to physical units using the calibration/sensitivity matrix and amplifier gain (as in this notebook).</p>
</section>
<section id="typical-outputs-and-data-format" class="level3">
<h3 class="anchored" data-anchor-id="typical-outputs-and-data-format">Typical outputs and data format</h3>
<ul>
<li>Time series sampled at a fixed sampling rate (fs), e.g., 100–2000 Hz.</li>
<li>Per-sample vectors: [Fx, Fy, Fz, Mx, My, Mz] (or voltages to convert).</li>
<li>Common file/column names: Time, VFx/VFx, VFy/Fy, VFz/Fz, VMx/Mx, VMy/My, VMz/Mz.</li>
<li>Units after conversion: Forces in newtons (N), moments in N·m; CoP usually reported in meters or mm.</li>
</ul>
</section>
<section id="key-practical-notes-pitfalls" class="level3">
<h3 class="anchored" data-anchor-id="key-practical-notes-pitfalls">Key practical notes / pitfalls</h3>
<ul>
<li>Calibration: raw voltages must be converted using the device’s sensitivity matrix and amplifier gain; check units carefully.</li>
<li>Sign conventions: verify force/moment sign conventions and plate origin/coordinate axes (affects CoP sign/direction).</li>
<li>Noise &amp; filtering: high‑frequency noise is common; apply appropriate low‑pass filtering (zero‑phase filtfilt preferred) and document cutoff/Nyquist.</li>
<li>Artifacts: check for clipping, spikes, drifts; inspect PSD and time traces before automated processing.</li>
<li>Sampling: ensure fs is recorded and used consistently for filtering, differentiation (speed), and spectral analysis.</li>
</ul>
</section>
<section id="typical-applications" class="level3">
<h3 class="anchored" data-anchor-id="typical-applications">Typical applications</h3>
<ul>
<li>Postural/balance tests (eyes open/closed, tandem stance)</li>
<li>Gait and running kinetics (ground reaction forces)</li>
<li>Jump testing, landing mechanics</li>
<li>Clinical and rehabilitation assessments</li>
</ul>
</section>
<section id="lets-see-what-our-forceplate-data-looks-like" class="level3">
<h3 class="anchored" data-anchor-id="lets-see-what-our-forceplate-data-looks-like">Let’s see what our force‑plate data looks like</h3>
<p>Quick checks to run now: - Inspect the first rows of EO/EC to confirm column alignment and Time indexing (df_EO.head(), df_EC.head()). - Draw diagnostic voltage traces to spot spikes, clipping, or offsets (use the <code>plot_voltage_data(...)</code> helper).</p>
<div id="8c774f4a" class="cell" data-execution_count="86">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eyes Open Dataframe:</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_EO.head())</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eyes Closed Dataframe:</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_EC.head())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Eyes Open Dataframe:

    Time       VFx       VFy       VFz       VMx       VMy       VMz  \
0  0.000  0.012344 -0.087344  2.551563 -1.753438  0.204531 -0.745938   
1  0.001  0.014687 -0.088281  2.552812 -1.759375  0.201094 -0.749375   
2  0.002  0.013281 -0.088281  2.553438 -1.759375  0.203437 -0.750938   
3  0.003  0.015000 -0.088438  2.552188 -1.758125  0.199844 -0.752344   
4  0.004  0.010156 -0.089844  2.551875 -1.761719  0.200937 -0.749531   

         Fx        Fy          Fz         Mx        My         Mz  
0  1.691807 -7.492642  728.781669 -64.231260  5.374828 -11.761739  
1  1.864985 -7.553040  729.139203 -64.447059  5.275992 -11.815882  
2  1.762143 -7.553160  729.317995 -64.447298  5.343027 -11.839789  
3  1.886389 -7.561766  728.960631 -64.401112  5.240377 -11.862005  
4  1.537110 -7.662102  728.872340 -64.532107  5.271112 -11.819274  


Eyes Closed Dataframe:

    Time       VFx       VFy       VFz       VMx       VMy       VMz  \
0  0.000  0.001406 -0.084531  2.547188 -1.909531  0.104844 -0.735156   
1  0.001  0.000625 -0.087656  2.549375 -1.912813  0.105313 -0.734844   
2  0.002 -0.001250 -0.087656  2.547813 -1.913281  0.105625 -0.735938   
3  0.003 -0.002188 -0.087031  2.546250 -1.908906  0.106094 -0.731250   
4  0.004 -0.005469 -0.086406  2.549375 -1.909375  0.107813 -0.736875   

         Fx        Fy          Fz         Mx        My         Mz  
0  1.022489 -7.110280  727.538129 -69.898703  2.507629 -11.615878  
1  0.966270 -7.337180  728.164786 -70.018846  2.520398 -11.612384  
2  0.830318 -7.333592  727.718632 -70.035494  2.529457 -11.629300  
3  0.760869 -7.294226  727.271674 -69.876284  2.543203 -11.556364  
4  0.521829 -7.247805  728.163108 -69.893502  2.591798 -11.643391  </code></pre>
</div>
</div>
</section>
<section id="plotting-helper-how-to-use-these-diagnostic-plots" class="level3">
<h3 class="anchored" data-anchor-id="plotting-helper-how-to-use-these-diagnostic-plots">Plotting helper — how to use these diagnostic plots</h3>
<p>The plotting helper draws voltage traces for all force (Fx,Fy,Fz) and moment (Mx,My,Mz) channels for EO and EC. Use it as a first pass to: - Check relative amplitudes and variability between conditions (e.g., increased sway in EC). - Spot spikes, clipping, or missing segments that must be handled before filtering. - Select representative time windows for spectral analysis and PSD estimation (avoid start/end transients).</p>
<p>Practical tip: plot short windows (10–30 s) to inspect detail, and longer windows to assess overall signal</p>
<div id="10fc5867" class="cell" data-execution_count="66">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting function</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_voltage_data(df_EO, df_EC, time_range<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">30</span>), figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), dpi<span class="op">=</span><span class="dv">100</span>, pad<span class="op">=</span><span class="fl">2.0</span>):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Plot voltage data from two dataframes (EO and EC) over a specified time range.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">    This function generates six subplots corresponding to force (Fx, Fy, Fz) and moment (Mx, My, Mz) voltage signals, comparing data from two different conditions (EO and EC).</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">        df_EO (DataFrame): Data containing EO (Eyes Open) condition, with columns 'Time', 'VFx', 'VFy', 'VFz', 'VMx', 'VMy', 'VMz'.</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">        df_EC (DataFrame): Data containing EC (Eyes Closed) condition, with the same columns as `df_EO`.</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">        time_range (tuple, optional): The time range (start, end) in seconds for plotting. Defaults to (15, 30).</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">        figsize (tuple, optional): The figure size as (width, height). Defaults to (10, 8).</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">        dpi (int, optional): Dots per inch (DPI) setting for the figure resolution. Defaults to 100.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">        pad (float, optional): Padding for `tight_layout` to adjust subplot spacing. Defaults to 2.0.</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises:</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError: If the input dataframes do not contain the required voltage columns.</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; plot_voltage_data(df_EO, df_EC, time_range=(10, 25))</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create subplots</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    fig, axs <span class="op">=</span> plt.subplots(<span class="dv">6</span>, <span class="dv">1</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">False</span>, dpi<span class="op">=</span>dpi, figsize<span class="op">=</span>figsize)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot data for each subplot</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (col, title) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>([<span class="st">'VFx'</span>, <span class="st">'VFy'</span>, <span class="st">'VFz'</span>, <span class="st">'VMx'</span>, <span class="st">'VMy'</span>, <span class="st">'VMz'</span>],</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>                                         [<span class="st">'Fx voltage'</span>, <span class="st">'Fy voltage'</span>, <span class="st">'Fz voltage'</span>, <span class="st">'Mx voltage'</span>, <span class="st">'My voltage'</span>, <span class="st">'Mz voltage'</span>])):</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        axs[i].plot(df_EO[<span class="st">'Time'</span>], df_EO[col], color<span class="op">=</span><span class="st">'tab:blue'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="st">'EO'</span>)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        axs[i].plot(df_EC[<span class="st">'Time'</span>], df_EC[col], color<span class="op">=</span><span class="st">'tab:orange'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="st">'EC'</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        axs[i].legend(bbox_to_anchor<span class="op">=</span>(<span class="fl">1.1</span>, <span class="dv">1</span>), loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        axs[i].set_title(title)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set x-axis label and limits</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Time [s]'</span>)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    plt.xlim(time_range)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set y-axis label for the middle subplot</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">2</span>].set_ylabel(<span class="st">'Voltage [V]'</span>)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    fig.align_ylabels()</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adjust layout</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout(pad<span class="op">=</span>pad)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show the plot</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Here we will only plot between time t=5s and t=15s</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>plot_voltage_data(df_EO, df_EC, time_range<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">15</span>), figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), dpi<span class="op">=</span><span class="dv">100</span>, pad<span class="op">=</span><span class="fl">2.0</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="BalanceSignalProcessingTutorial_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="spectral-analysis-helper-interpretation-and-practical-use" class="level3">
<h3 class="anchored" data-anchor-id="spectral-analysis-helper-interpretation-and-practical-use">Spectral analysis helper — interpretation and practical use</h3>
<p>This helper uses Welch’s method to compute a power spectral density (PSD) and finds a cutoff frequency where the cumulative power exceeds a chosen percentage (e.g., 95–99%). Use it to pick data‑driven low‑pass cutoffs.</p>
<p>Key points: - Low-frequency peaks often correspond to physiologically meaningful sway; high-frequency broadband tails are usually noise. - Choosing a cumulative power threshold keeps most signal energy while excluding high-frequency noise — common thresholds are 95%–99%. - For short signals, PSD estimates can be noisy; increase segment length (if available) to improve resolution.</p>
<p>Diagnostics (use <code>plot=True</code>): - Check the PSD (semilogy) for dominant components and the cumulative power curve for a clear knee where energy levels off. - Inspect the vertical line indicating the selected cutoff — it should follow main low-frequency peaks but precede broadband noise.</p>
<p>Takeaway: prefer a visually justified, data-driven cutoff rather than an arbitrary frequency; the helper provides both the numeric cutoff and diagnostic plots to justify it.</p>
<div id="23fed047" class="cell" data-execution_count="75">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This a helper function for determining cutoff frequencies using cumulative power spectrum thresholding</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spectral_analysis(</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    data: Union[np.ndarray, pd.Series, pd.DataFrame, Sequence[<span class="bu">float</span>]],</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    sampling_freq: <span class="bu">float</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    nperseg: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    window: <span class="bu">str</span> <span class="op">=</span> <span class="st">"hann"</span>,</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    threshold: <span class="bu">float</span> <span class="op">=</span> <span class="dv">99</span>,</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    plot: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Estimate a cutoff frequency from the power spectral density of a 1-D signal.</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">    The function computes a Welch PSD and finds the frequency at which the</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">    cumulative power (from low to high frequency) exceeds ``threshold`` percent</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">    of the total power.</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">    data:</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co">        1-D signal to analyze. Accepts a NumPy array, pandas Series or a 1-column</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">        DataFrame. Passing a multi-column DataFrame will raise ``ValueError``.</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">    sampling_freq:</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Sampling frequency of the signal in Hz.</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co">    nperseg:</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co">        Length of each segment used by Welch's method. If ``None`` defaults to</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="co">        the signal length. Larger values give better frequency resolution but</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="co">        fewer averages.</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="co">    window:</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="co">        Window name passed to ``scipy.signal.welch`` (default: ``'hann'``).</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co">    threshold:</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co">        Percentage (0-100) of cumulative power to use as the cutoff. Default is</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="co">        99 (i.e. when 99% of the power is reached).</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="co">    plot:</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="co">        If True, display diagnostic plots using matplotlib. Specifically,</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co">        ``spectral_analysis`` shows two stacked subplots: the PSD (semilogy)</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="co">        and the cumulative power (%) with a vertical dashed line at the</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="co">        detected cutoff frequency. The function also logs the frequency</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="co">                vector shape and the selected cutoff index at DEBUG level when</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a><span class="co">                plotting. Note that matplotlib must be available and a suitable</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="co">                display/backend present for figures to appear.</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a><span class="co">        Notes on threshold</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="co">        ------------------</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``threshold`` must be within (0, 100]. Passing values outside this</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a><span class="co">            range raises ``ValueError``. ``threshold`` is interpreted as a</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="co">            percentage of cumulative power (0-100).</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="co">    float</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a><span class="co">        The cutoff frequency in Hz where the cumulative power first exceeds</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a><span class="co">        ``threshold``. If the threshold is never exceeded (e.g., threshold &gt; 100</span></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a><span class="co">        or numerical issues), the function returns the lowest frequency ``f[0]``.</span></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a><span class="co">    ------</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a><span class="co">    ValueError</span></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a><span class="co">        If ``data`` is empty, if ``sampling_freq`` is not positive, or if a</span></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a><span class="co">        multi-column DataFrame is provided.</span></span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a><span class="co">    Notes</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a><span class="co">    -----</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a><span class="co">    - The function does not currently handle NaNs; callers should pre-process</span></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a><span class="co">      the signal (interpolate or drop) before calling.</span></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a><span class="co">    - The return type is a Python float (converted from NumPy types when</span></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a><span class="co">      necessary).</span></span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a><span class="co">    Examples</span></span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; import numpy as np</span></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; t = np.linspace(0, 1.0, 1000, endpoint=False)</span></span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; x = np.sin(2*np.pi*5*t)</span></span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; spectral_analysis(x, sampling_freq=1000, threshold=90)</span></span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a><span class="co">    5.0</span></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate threshold</span></span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> (<span class="dv">0</span> <span class="op">&lt;</span> <span class="bu">float</span>(threshold) <span class="op">&lt;=</span> <span class="dv">100</span>):</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"threshold must be between 0 (exclusive) and 100 (inclusive)"</span>)</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert input to 1D numpy array</span></span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(data, pd.DataFrame):</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> data.shape[<span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> data.iloc[:, <span class="dv">0</span>]</span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(</span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>                <span class="st">"spectral_analysis expects a 1D signal, not a multi-column DataFrame."</span>)</span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(data, pd.Series):</span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> data.values</span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(data, <span class="bu">list</span>):</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> np.array(data)</span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(data) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input data is empty"</span>)</span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sampling_freq <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Sampling frequency must be positive"</span>)</span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> nperseg <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>        nperseg <span class="op">=</span> <span class="bu">len</span>(data)</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>    f, Pxx <span class="op">=</span> welch(data, fs<span class="op">=</span>sampling_freq, nperseg<span class="op">=</span>nperseg, window<span class="op">=</span>window)</span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate cumulative power spectrum</span></span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>    cumulative_power <span class="op">=</span> np.cumsum(Pxx)</span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalize cumulative power to get a percentage</span></span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a>    cumulative_power_percent <span class="op">=</span> cumulative_power <span class="op">/</span> cumulative_power[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find the index where the cumulative power levels off</span></span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a>    cutoff_index <span class="op">=</span> np.argmax(</span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a>        cumulative_power_percent <span class="op">&gt;</span> threshold</span>
<span id="cb8-112"><a href="#cb8-112" aria-hidden="true" tabindex="-1"></a>    )  <span class="co"># Use the specified threshold</span></span>
<span id="cb8-113"><a href="#cb8-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-114"><a href="#cb8-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> plot <span class="op">==</span> <span class="va">True</span>:</span>
<span id="cb8-115"><a href="#cb8-115" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Plot the results</span></span>
<span id="cb8-116"><a href="#cb8-116" aria-hidden="true" tabindex="-1"></a>        plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb8-117"><a href="#cb8-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-118"><a href="#cb8-118" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Plot Power Spectral Density</span></span>
<span id="cb8-119"><a href="#cb8-119" aria-hidden="true" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb8-120"><a href="#cb8-120" aria-hidden="true" tabindex="-1"></a>        plt.semilogy(f, Pxx)</span>
<span id="cb8-121"><a href="#cb8-121" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="st">'Power Spectral Density'</span>)</span>
<span id="cb8-122"><a href="#cb8-122" aria-hidden="true" tabindex="-1"></a>        plt.xlabel(<span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb8-123"><a href="#cb8-123" aria-hidden="true" tabindex="-1"></a>        plt.ylabel(<span class="st">'Power/Frequency (dB/Hz)'</span>)</span>
<span id="cb8-124"><a href="#cb8-124" aria-hidden="true" tabindex="-1"></a>        plt.grid(<span class="va">True</span>)</span>
<span id="cb8-125"><a href="#cb8-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-126"><a href="#cb8-126" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Plot Cumulative Power Spectrum</span></span>
<span id="cb8-127"><a href="#cb8-127" aria-hidden="true" tabindex="-1"></a>        plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb8-128"><a href="#cb8-128" aria-hidden="true" tabindex="-1"></a>        plt.plot(f, cumulative_power_percent)</span>
<span id="cb8-129"><a href="#cb8-129" aria-hidden="true" tabindex="-1"></a>        plt.axvline(x<span class="op">=</span>f[cutoff_index], color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>,</span>
<span id="cb8-130"><a href="#cb8-130" aria-hidden="true" tabindex="-1"></a>                    label<span class="op">=</span><span class="ss">f'Cutoff Frequency: </span><span class="sc">{</span>f[cutoff_index]<span class="sc">:.2f}</span><span class="ss"> Hz'</span>)</span>
<span id="cb8-131"><a href="#cb8-131" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="st">'Cumulative Power Spectrum'</span>)</span>
<span id="cb8-132"><a href="#cb8-132" aria-hidden="true" tabindex="-1"></a>        plt.xlabel(<span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb8-133"><a href="#cb8-133" aria-hidden="true" tabindex="-1"></a>        plt.ylabel(<span class="st">'Cumulative Power (%)'</span>)</span>
<span id="cb8-134"><a href="#cb8-134" aria-hidden="true" tabindex="-1"></a>        plt.legend()</span>
<span id="cb8-135"><a href="#cb8-135" aria-hidden="true" tabindex="-1"></a>        plt.grid(<span class="va">True</span>)</span>
<span id="cb8-136"><a href="#cb8-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-137"><a href="#cb8-137" aria-hidden="true" tabindex="-1"></a>        plt.tight_layout()</span>
<span id="cb8-138"><a href="#cb8-138" aria-hidden="true" tabindex="-1"></a>        plt.show()</span>
<span id="cb8-139"><a href="#cb8-139" aria-hidden="true" tabindex="-1"></a>    _LOGGER.debug(<span class="st">"spectral_analysis: f.shape=</span><span class="sc">%s</span><span class="st">, cutoff_index=</span><span class="sc">%s</span><span class="st">"</span>, f.shape, cutoff_index)</span>
<span id="cb8-140"><a href="#cb8-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-141"><a href="#cb8-141" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f[cutoff_index]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="filtering-helper-summary-and-expected-behavior" class="level3">
<h3 class="anchored" data-anchor-id="filtering-helper-summary-and-expected-behavior">Filtering helper — summary and expected behavior</h3>
<p>This helper centralizes realistic filtering choices: cutoff estimation, NaN handling, and application of a zero‑phase Butterworth filter when possible.</p>
<p>Main behaviors: - Accepts lists, NumPy arrays, pandas Series/DataFrames and preserves the input shape/type on return where practical. - NaN handling: <code>'raise'</code> (error), <code>'interpolate'</code> (linear/interpolate + edge fill), or <code>'fill'</code> (constant). Interpolate is a reasonable default for isolated missing samples. - Cutoff selection: <code>custom_cutoff_frequency</code> forces a fixed cutoff; otherwise per‑channel cutoffs are estimated by <code>spectral_analysis</code> using a cumulative power threshold. - <code>filtfilt</code> (zero‑phase) is preferred; for very short signals the code falls back to <code>lfilter</code> and logs a warning (this introduces phase shift).</p>
<p>Verification checklist after filtering: - Plot raw vs filtered traces to ensure smoothing without removing expected low‑frequency structure. - Confirm cutoff frequencies are below Nyquist and in a sensible range for your task (e.g., &lt; fs/2).</p>
<p>What is the Nyquist frequency (brief)? - Definition: Nyquist frequency = fs / 2, where fs is the sampling rate (Hz).<br>
Example: if fs = 1000 Hz, Nyquist = 500 Hz. - Why it matters: the Nyquist frequency is the highest frequency that can be represented without aliasing according to the Nyquist–Shannon sampling theorem. Frequencies above Nyquist will fold (alias) into lower frequencies and corrupt your signal. - Practical implication for filtering: Never design a low‑pass cutoff &gt;= Nyquist. In practice, clamp cutoffs safely below Nyquist (the helper uses 95% of Nyquist when necessary).</p>
<div id="7a91888b" class="cell" data-execution_count="76">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This is a helper function for filtering timeseries data</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> filter_timeseries_data(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    data: Union[List[<span class="bu">float</span>], np.ndarray, pd.DataFrame, pd.Series],</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    sampling_freq: <span class="bu">float</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    custom_cutoff_frequency: Optional[<span class="bu">float</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    threshold: <span class="bu">float</span> <span class="op">=</span> <span class="dv">99</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    plot: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>,</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    rolling_window: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    butter_order: <span class="bu">int</span> <span class="op">=</span> <span class="dv">4</span>,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    nan_policy: <span class="bu">str</span> <span class="op">=</span> <span class="st">"interpolate"</span>,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    nan_fill_value: Optional[<span class="bu">float</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Union[List[<span class="bu">float</span>], np.ndarray, pd.DataFrame, pd.Series]:</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Apply a low-pass Butterworth filter to time-series data.</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="co">    The function accepts lists, 1-D NumPy arrays, 2-D NumPy arrays with shape</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co">    (n_samples, n_channels), pandas Series, or pandas DataFrame. When</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">    ``custom_cutoff_frequency`` is not given, a cutoff frequency is estimated</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">    per channel using :func:`spectral_analysis` with the provided ``threshold``.</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co">    data:</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Input time-series. Supported types:</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``list`` (treated as 1-D signal, returns ``list``)</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``np.ndarray`` (1-D or 2-D). For 2-D arrays filtering is applied to</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co">          each column and the resulting array has the same shape.</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``pandas.Series`` (returns ``pandas.Series`` with the same index/name)</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``pandas.DataFrame`` (filters each column and returns a DataFrame</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="co">          preserving index and columns)</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="co">    sampling_freq:</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="co">        Sampling frequency in Hz.</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="co">    custom_cutoff_frequency:</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="co">        If provided, this scalar cutoff frequency (Hz) is used for all</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="co">        channels. Otherwise, the cutoff is estimated independently per channel</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a><span class="co">        using ``spectral_analysis`` and the given ``threshold``.</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a><span class="co">    threshold:</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a><span class="co">        Cumulative power percentage (0-100) used by ``spectral_analysis`` when</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a><span class="co">        estimating cutoffs.</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a><span class="co">    plot:</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="co">        If True, enables plotting inside the underlying ``spectral_analysis``</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="co">        calls and shows the PSD/cumulative plots. Plotting is only triggered</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a><span class="co">        when cutoffs are estimated automatically (i.e., ``custom_cutoff_frequency``</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a><span class="co">        is ``None``). For multi-channel inputs this may display one figure per</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a><span class="co">        channel and can be slow or produce many windows; set ``plot=False`` to</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="co">        suppress plotting.</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a><span class="co">    rolling_window:</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a><span class="co">        Integer window size used to apply a simple moving average to any</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a><span class="co">        pandas.Series inputs before filtering to reduce very short-term noise.</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a><span class="co">    butter_order:</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a><span class="co">        Integer order of the Butterworth filter. Defaults to 4 for a</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a><span class="co">        4th-order low-pass filter. Increasing the order makes the filter</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="co">        steeper but may introduce more ringing/artifacts.</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a><span class="co">    nan_policy:</span></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a><span class="co">        How to handle NaN values in the input data. Options:</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``'raise'`` (default): raise ``ValueError`` if NaNs are present.</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``'interpolate'``: interpolate NaNs along the time axis (linear</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a><span class="co">          interpolation). Works for arrays and pandas objects.</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``'fill'``: replace NaNs with ``nan_fill_value`` (must be provided).</span></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a><span class="co">    nan_fill_value:</span></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a><span class="co">        Value used to fill NaNs when ``nan_policy=='fill'``. If None and</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a><span class="co">        ``nan_policy=='fill'``, a ValueError is raised.</span></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a><span class="co">        Notes on filtering behavior</span></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a><span class="co">        --------------------------</span></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a><span class="co">        - The filter is designed with ``scipy.signal.butter`` using ``butter_order``</span></span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a><span class="co">            and applied with ``filtfilt`` for zero-phase filtering when possible.</span></span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a><span class="co">            For very short signals where ``filtfilt`` cannot be used the code falls</span></span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a><span class="co">            back to ``lfilter`` and logs a </span><span class="al">WARNING</span><span class="co">; this introduces a phase shift</span></span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a><span class="co">            relative to zero-phase filtering.</span></span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a><span class="co">        - ``butter_order`` is validated to be an integer &gt;= 1.</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns</span></span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a><span class="co">    list | np.ndarray | pandas.Series | pandas.DataFrame</span></span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a><span class="co">        Filtered data with the same type and shape as the input. For numpy</span></span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a><span class="co">        arrays, columns are treated along axis=1 (i.e., shape (n_samples,</span></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a><span class="co">        n_channels)).</span></span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises</span></span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a><span class="co">    ------</span></span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a><span class="co">    ValueError</span></span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a><span class="co">        If ``data`` is not one of the supported types.</span></span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a><span class="co">    Notes</span></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a><span class="co">    -----</span></span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a><span class="co">        - The filter is a Butterworth low-pass filter implemented via</span></span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a><span class="co">            ``scipy.signal.butter`` and applied with ``filtfilt`` for zero-phase</span></span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a><span class="co">            filtering. The default order is 4 (4th-order) but this can be changed</span></span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a><span class="co">            using the ``butter_order`` parameter.</span></span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a><span class="co">        - If the estimated or provided cutoff is &gt;= Nyquist (fs/2) it is clamped</span></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a><span class="co">            to 95% of Nyquist. If it is &lt;= 0 it is clamped to 5% of Nyquist. These</span></span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a><span class="co">            behaviours are intentional to avoid invalid filter designs.</span></span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a><span class="co">            - NaN handling: use the ``nan_policy`` parameter to control behavior.</span></span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a><span class="co">                Options are ``'raise'`` (default), ``'interpolate'``, or ``'fill'``.</span></span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a><span class="co">                When ``'fill'`` is selected, ``nan_fill_value`` must be provided.</span></span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a><span class="co">        - Estimating cutoffs via spectral analysis for many channels may be slow;</span></span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a><span class="co">            provide ``custom_cutoff_frequency`` when possible for performance.</span></span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a><span class="co">    Examples</span></span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a><span class="co">    Filter a 1-D numpy signal:</span></span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; filtered = filter_timeseries_data(np.array(x), sampling_freq=1000)</span></span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a><span class="co">    Filter a pandas DataFrame (each column filtered independently):</span></span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a><span class="co">    &gt;&gt;&gt; filtered_df = filter_timeseries_data(df, sampling_freq=200)</span></span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Accept list, ndarray, DataFrame, Series</span></span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a>    input_type <span class="op">=</span> <span class="va">None</span></span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(data, <span class="bu">list</span>):</span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert list to numpy array</span></span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> np.array(data)</span>
<span id="cb9-114"><a href="#cb9-114" aria-hidden="true" tabindex="-1"></a>        input_type <span class="op">=</span> <span class="st">'list'</span></span>
<span id="cb9-115"><a href="#cb9-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(data, np.ndarray):</span>
<span id="cb9-116"><a href="#cb9-116" aria-hidden="true" tabindex="-1"></a>        input_type <span class="op">=</span> <span class="st">'ndarray'</span></span>
<span id="cb9-117"><a href="#cb9-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(data, pd.DataFrame):</span>
<span id="cb9-118"><a href="#cb9-118" aria-hidden="true" tabindex="-1"></a>        input_type <span class="op">=</span> <span class="st">'dataframe'</span></span>
<span id="cb9-119"><a href="#cb9-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(data, pd.Series):</span>
<span id="cb9-120"><a href="#cb9-120" aria-hidden="true" tabindex="-1"></a>        input_type <span class="op">=</span> <span class="st">'series'</span></span>
<span id="cb9-121"><a href="#cb9-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb9-122"><a href="#cb9-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(</span>
<span id="cb9-123"><a href="#cb9-123" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Unsupported data type. Please provide a list, NumPy array, pandas DataFrame, or pandas Series."</span>)</span>
<span id="cb9-124"><a href="#cb9-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-125"><a href="#cb9-125" aria-hidden="true" tabindex="-1"></a>    fs <span class="op">=</span> <span class="bu">float</span>(sampling_freq)</span>
<span id="cb9-126"><a href="#cb9-126" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate butter_order</span></span>
<span id="cb9-127"><a href="#cb9-127" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(butter_order, <span class="bu">int</span>) <span class="kw">or</span> butter_order <span class="op">&lt;</span> <span class="dv">1</span>:</span>
<span id="cb9-128"><a href="#cb9-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"butter_order must be an integer &gt;= 1"</span>)</span>
<span id="cb9-129"><a href="#cb9-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-130"><a href="#cb9-130" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate nan handling policy</span></span>
<span id="cb9-131"><a href="#cb9-131" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> nan_policy <span class="kw">not</span> <span class="kw">in</span> (<span class="st">"raise"</span>, <span class="st">"interpolate"</span>, <span class="st">"fill"</span>):</span>
<span id="cb9-132"><a href="#cb9-132" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"nan_policy must be one of 'raise', 'interpolate', or 'fill'"</span>)</span>
<span id="cb9-133"><a href="#cb9-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-134"><a href="#cb9-134" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle NaNs according to policy. For pandas objects use pandas methods;</span></span>
<span id="cb9-135"><a href="#cb9-135" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for numpy arrays use interpolation via numpy where appropriate.</span></span>
<span id="cb9-136"><a href="#cb9-136" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> input_type <span class="kw">in</span> (<span class="st">"dataframe"</span>, <span class="st">"series"</span>):</span>
<span id="cb9-137"><a href="#cb9-137" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nan_policy <span class="op">==</span> <span class="st">"raise"</span>:</span>
<span id="cb9-138"><a href="#cb9-138" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="bu">isinstance</span>(data, pd.DataFrame) <span class="kw">and</span> data.isna().values.<span class="bu">any</span>()) <span class="kw">or</span> (</span>
<span id="cb9-139"><a href="#cb9-139" aria-hidden="true" tabindex="-1"></a>                <span class="bu">isinstance</span>(data, pd.Series) <span class="kw">and</span> data.isna().<span class="bu">any</span>()</span>
<span id="cb9-140"><a href="#cb9-140" aria-hidden="true" tabindex="-1"></a>            ):</span>
<span id="cb9-141"><a href="#cb9-141" aria-hidden="true" tabindex="-1"></a>                _LOGGER.debug(<span class="st">"NaNs detected in pandas input and nan_policy='raise' -&gt; raising ValueError"</span>)</span>
<span id="cb9-142"><a href="#cb9-142" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"NaN values found in input; set nan_policy to 'interpolate' or 'fill' to handle them"</span>)</span>
<span id="cb9-143"><a href="#cb9-143" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> nan_policy <span class="op">==</span> <span class="st">"interpolate"</span>:</span>
<span id="cb9-144"><a href="#cb9-144" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Linear interpolation along the index (time axis)</span></span>
<span id="cb9-145"><a href="#cb9-145" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">isinstance</span>(data, pd.DataFrame):</span>
<span id="cb9-146"><a href="#cb9-146" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> data.interpolate(axis<span class="op">=</span><span class="dv">0</span>).ffill().bfill()</span>
<span id="cb9-147"><a href="#cb9-147" aria-hidden="true" tabindex="-1"></a>                _LOGGER.debug(<span class="st">"Interpolated NaNs in pandas DataFrame input (axis=0) and applied ffill/bfill for edges"</span>)</span>
<span id="cb9-148"><a href="#cb9-148" aria-hidden="true" tabindex="-1"></a>                _LOGGER.info(<span class="st">"Interpolated NaNs in pandas DataFrame input (nan_policy='interpolate')"</span>)</span>
<span id="cb9-149"><a href="#cb9-149" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-150"><a href="#cb9-150" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> data.interpolate().ffill().bfill()</span>
<span id="cb9-151"><a href="#cb9-151" aria-hidden="true" tabindex="-1"></a>                _LOGGER.debug(<span class="st">"Interpolated NaNs in pandas Series input and applied ffill/bfill for edges"</span>)</span>
<span id="cb9-152"><a href="#cb9-152" aria-hidden="true" tabindex="-1"></a>                _LOGGER.info(<span class="st">"Interpolated NaNs in pandas Series input (nan_policy='interpolate')"</span>)</span>
<span id="cb9-153"><a href="#cb9-153" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># fill</span></span>
<span id="cb9-154"><a href="#cb9-154" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nan_fill_value <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-155"><a href="#cb9-155" aria-hidden="true" tabindex="-1"></a>                _LOGGER.debug(<span class="st">"nan_policy='fill' but nan_fill_value is None -&gt; raising ValueError"</span>)</span>
<span id="cb9-156"><a href="#cb9-156" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"nan_fill_value must be provided when nan_policy=='fill'"</span>)</span>
<span id="cb9-157"><a href="#cb9-157" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> data.fillna(nan_fill_value)</span>
<span id="cb9-158"><a href="#cb9-158" aria-hidden="true" tabindex="-1"></a>            _LOGGER.debug(<span class="st">"Filled NaNs in pandas input with value=</span><span class="sc">%s</span><span class="st">"</span>, nan_fill_value)</span>
<span id="cb9-159"><a href="#cb9-159" aria-hidden="true" tabindex="-1"></a>            _LOGGER.info(<span class="st">"Filled NaNs in pandas input with value=</span><span class="sc">%s</span><span class="st"> (nan_policy='fill')"</span>, nan_fill_value)</span>
<span id="cb9-160"><a href="#cb9-160" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> input_type <span class="kw">in</span> (<span class="st">"ndarray"</span>, <span class="st">"list"</span>):</span>
<span id="cb9-161"><a href="#cb9-161" aria-hidden="true" tabindex="-1"></a>        arr <span class="op">=</span> np.asarray(data, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb9-162"><a href="#cb9-162" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr.ndim <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-163"><a href="#cb9-163" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> np.isnan(arr).<span class="bu">any</span>():</span>
<span id="cb9-164"><a href="#cb9-164" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> nan_policy <span class="op">==</span> <span class="st">"raise"</span>:</span>
<span id="cb9-165"><a href="#cb9-165" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.debug(<span class="st">"NaNs detected in 1D ndarray and nan_policy='raise' -&gt; raising ValueError"</span>)</span>
<span id="cb9-166"><a href="#cb9-166" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"NaN values found in input array; set nan_policy to 'interpolate' or 'fill' to handle them"</span>)</span>
<span id="cb9-167"><a href="#cb9-167" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> nan_policy <span class="op">==</span> <span class="st">"interpolate"</span>:</span>
<span id="cb9-168"><a href="#cb9-168" aria-hidden="true" tabindex="-1"></a>                    idx <span class="op">=</span> np.arange(arr.size)</span>
<span id="cb9-169"><a href="#cb9-169" aria-hidden="true" tabindex="-1"></a>                    mask <span class="op">=</span> np.isfinite(arr)</span>
<span id="cb9-170"><a href="#cb9-170" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="kw">not</span> mask.<span class="bu">all</span>():</span>
<span id="cb9-171"><a href="#cb9-171" aria-hidden="true" tabindex="-1"></a>                        arr <span class="op">=</span> np.interp(idx, idx[mask], arr[mask])</span>
<span id="cb9-172"><a href="#cb9-172" aria-hidden="true" tabindex="-1"></a>                        _LOGGER.debug(<span class="st">"Interpolated NaNs in 1D ndarray input using numpy.interp"</span>)</span>
<span id="cb9-173"><a href="#cb9-173" aria-hidden="true" tabindex="-1"></a>                        _LOGGER.info(<span class="st">"Interpolated NaNs in 1D ndarray input (nan_policy='interpolate')"</span>)</span>
<span id="cb9-174"><a href="#cb9-174" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:  <span class="co"># fill</span></span>
<span id="cb9-175"><a href="#cb9-175" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> nan_fill_value <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-176"><a href="#cb9-176" aria-hidden="true" tabindex="-1"></a>                        _LOGGER.debug(<span class="st">"nan_policy='fill' but nan_fill_value is None -&gt; raising ValueError"</span>)</span>
<span id="cb9-177"><a href="#cb9-177" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"nan_fill_value must be provided when nan_policy=='fill'"</span>)</span>
<span id="cb9-178"><a href="#cb9-178" aria-hidden="true" tabindex="-1"></a>                    arr <span class="op">=</span> np.where(np.isnan(arr), nan_fill_value, arr)</span>
<span id="cb9-179"><a href="#cb9-179" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.debug(<span class="st">"Filled NaNs in 1D ndarray input with value=</span><span class="sc">%s</span><span class="st">"</span>, nan_fill_value)</span>
<span id="cb9-180"><a href="#cb9-180" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.info(<span class="st">"Filled NaNs in 1D ndarray input with value=</span><span class="sc">%s</span><span class="st"> (nan_policy='fill')"</span>, nan_fill_value)</span>
<span id="cb9-181"><a href="#cb9-181" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> arr</span>
<span id="cb9-182"><a href="#cb9-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-183"><a href="#cb9-183" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 2D array: process each column</span></span>
<span id="cb9-184"><a href="#cb9-184" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> np.isnan(arr).<span class="bu">any</span>():</span>
<span id="cb9-185"><a href="#cb9-185" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> nan_policy <span class="op">==</span> <span class="st">"raise"</span>:</span>
<span id="cb9-186"><a href="#cb9-186" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.debug(<span class="st">"NaNs detected in 2D ndarray and nan_policy='raise' -&gt; raising ValueError"</span>)</span>
<span id="cb9-187"><a href="#cb9-187" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"NaN values found in input array; set nan_policy to 'interpolate' or 'fill' to handle them"</span>)</span>
<span id="cb9-188"><a href="#cb9-188" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> nan_policy <span class="op">==</span> <span class="st">"interpolate"</span>:</span>
<span id="cb9-189"><a href="#cb9-189" aria-hidden="true" tabindex="-1"></a>                    arr2 <span class="op">=</span> arr.copy()</span>
<span id="cb9-190"><a href="#cb9-190" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(arr2.shape[<span class="dv">1</span>]):</span>
<span id="cb9-191"><a href="#cb9-191" aria-hidden="true" tabindex="-1"></a>                        col <span class="op">=</span> arr2[:, i]</span>
<span id="cb9-192"><a href="#cb9-192" aria-hidden="true" tabindex="-1"></a>                        idx <span class="op">=</span> np.arange(col.size)</span>
<span id="cb9-193"><a href="#cb9-193" aria-hidden="true" tabindex="-1"></a>                        mask <span class="op">=</span> np.isfinite(col)</span>
<span id="cb9-194"><a href="#cb9-194" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="kw">not</span> mask.<span class="bu">all</span>():</span>
<span id="cb9-195"><a href="#cb9-195" aria-hidden="true" tabindex="-1"></a>                            arr2[:, i] <span class="op">=</span> np.interp(idx, idx[mask], col[mask])</span>
<span id="cb9-196"><a href="#cb9-196" aria-hidden="true" tabindex="-1"></a>                    data <span class="op">=</span> arr2</span>
<span id="cb9-197"><a href="#cb9-197" aria-hidden="true" tabindex="-1"></a>                    n_nans <span class="op">=</span> <span class="bu">int</span>(np.isnan(arr).<span class="bu">sum</span>())</span>
<span id="cb9-198"><a href="#cb9-198" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.debug(<span class="st">"Interpolated NaNs in 2D ndarray input for </span><span class="sc">%d</span><span class="st"> columns"</span>, arr2.shape[<span class="dv">1</span>])</span>
<span id="cb9-199"><a href="#cb9-199" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.info(<span class="st">"Interpolated </span><span class="sc">%d</span><span class="st"> NaNs in 2D ndarray input across </span><span class="sc">%d</span><span class="st"> columns (nan_policy='interpolate')"</span>, n_nans, arr2.shape[<span class="dv">1</span>])</span>
<span id="cb9-200"><a href="#cb9-200" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb9-201"><a href="#cb9-201" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> nan_fill_value <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-202"><a href="#cb9-202" aria-hidden="true" tabindex="-1"></a>                        _LOGGER.debug(<span class="st">"nan_policy='fill' but nan_fill_value is None -&gt; raising ValueError"</span>)</span>
<span id="cb9-203"><a href="#cb9-203" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"nan_fill_value must be provided when nan_policy=='fill'"</span>)</span>
<span id="cb9-204"><a href="#cb9-204" aria-hidden="true" tabindex="-1"></a>                    data <span class="op">=</span> np.where(np.isnan(arr), nan_fill_value, arr)</span>
<span id="cb9-205"><a href="#cb9-205" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.debug(<span class="st">"Filled NaNs in 2D ndarray input with value=</span><span class="sc">%s</span><span class="st">"</span>, nan_fill_value)</span>
<span id="cb9-206"><a href="#cb9-206" aria-hidden="true" tabindex="-1"></a>                    n_nans <span class="op">=</span> <span class="bu">int</span>(np.isnan(arr).<span class="bu">sum</span>())</span>
<span id="cb9-207"><a href="#cb9-207" aria-hidden="true" tabindex="-1"></a>                    _LOGGER.info(<span class="st">"Filled </span><span class="sc">%d</span><span class="st"> NaNs in 2D ndarray input with value=</span><span class="sc">%s</span><span class="st"> (nan_policy='fill')"</span>, n_nans, nan_fill_value)</span>
<span id="cb9-208"><a href="#cb9-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-209"><a href="#cb9-209" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> apply_filter(column, cutoff_frequency):</span>
<span id="cb9-210"><a href="#cb9-210" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ensure cutoff_frequency is within (0, fs/2)</span></span>
<span id="cb9-211"><a href="#cb9-211" aria-hidden="true" tabindex="-1"></a>        nyquist <span class="op">=</span> fs <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb9-212"><a href="#cb9-212" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cutoff_frequency <span class="op">&gt;=</span> nyquist:</span>
<span id="cb9-213"><a href="#cb9-213" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Set to 95% of Nyquist if above or equal</span></span>
<span id="cb9-214"><a href="#cb9-214" aria-hidden="true" tabindex="-1"></a>            cutoff_frequency <span class="op">=</span> nyquist <span class="op">*</span> <span class="fl">0.95</span></span>
<span id="cb9-215"><a href="#cb9-215" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cutoff_frequency <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb9-216"><a href="#cb9-216" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Set to a small positive value if non-positive</span></span>
<span id="cb9-217"><a href="#cb9-217" aria-hidden="true" tabindex="-1"></a>            cutoff_frequency <span class="op">=</span> nyquist <span class="op">*</span> <span class="fl">0.05</span></span>
<span id="cb9-218"><a href="#cb9-218" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Design Butterworth filter with configurable order</span></span>
<span id="cb9-219"><a href="#cb9-219" aria-hidden="true" tabindex="-1"></a>        b, a <span class="op">=</span> butter(N<span class="op">=</span>butter_order, Wn<span class="op">=</span>cutoff_frequency,</span>
<span id="cb9-220"><a href="#cb9-220" aria-hidden="true" tabindex="-1"></a>                      btype<span class="op">=</span><span class="st">"low"</span>, fs<span class="op">=</span>fs, output<span class="op">=</span><span class="st">"ba"</span>)</span>
<span id="cb9-221"><a href="#cb9-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-222"><a href="#cb9-222" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Smooth very short-term noise for pandas Series inputs</span></span>
<span id="cb9-223"><a href="#cb9-223" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(column, pd.Series):</span>
<span id="cb9-224"><a href="#cb9-224" aria-hidden="true" tabindex="-1"></a>            column <span class="op">=</span> column.rolling(window<span class="op">=</span>rolling_window, min_periods<span class="op">=</span><span class="dv">1</span>).mean()</span>
<span id="cb9-225"><a href="#cb9-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-226"><a href="#cb9-226" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Work on numpy array copy for length/pad checks</span></span>
<span id="cb9-227"><a href="#cb9-227" aria-hidden="true" tabindex="-1"></a>        col_arr <span class="op">=</span> np.asarray(column, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb9-228"><a href="#cb9-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-229"><a href="#cb9-229" aria-hidden="true" tabindex="-1"></a>        <span class="co"># filtfilt requires length &gt; padlen where padlen = 3*(max(len(a), len(b)) - 1)</span></span>
<span id="cb9-230"><a href="#cb9-230" aria-hidden="true" tabindex="-1"></a>        padlen <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> (<span class="bu">max</span>(<span class="bu">len</span>(a), <span class="bu">len</span>(b)) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-231"><a href="#cb9-231" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col_arr.size <span class="op">&lt;=</span> padlen:</span>
<span id="cb9-232"><a href="#cb9-232" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Fallback to lfilter with a warning (introduces phase shift)</span></span>
<span id="cb9-233"><a href="#cb9-233" aria-hidden="true" tabindex="-1"></a>            _LOGGER.warning(</span>
<span id="cb9-234"><a href="#cb9-234" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Signal length </span><span class="sc">%d</span><span class="st"> &lt;= padlen </span><span class="sc">%d</span><span class="st"> for filtfilt (order=</span><span class="sc">%d</span><span class="st">). Falling back to lfilter which introduces phase shift."</span>,</span>
<span id="cb9-235"><a href="#cb9-235" aria-hidden="true" tabindex="-1"></a>                col_arr.size,</span>
<span id="cb9-236"><a href="#cb9-236" aria-hidden="true" tabindex="-1"></a>                padlen,</span>
<span id="cb9-237"><a href="#cb9-237" aria-hidden="true" tabindex="-1"></a>                butter_order,</span>
<span id="cb9-238"><a href="#cb9-238" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb9-239"><a href="#cb9-239" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lfilter(b, a, col_arr)</span>
<span id="cb9-240"><a href="#cb9-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-241"><a href="#cb9-241" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Zero-phase filtering</span></span>
<span id="cb9-242"><a href="#cb9-242" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filtfilt(b, a, col_arr)</span>
<span id="cb9-243"><a href="#cb9-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-244"><a href="#cb9-244" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> custom_cutoff_frequency <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb9-245"><a href="#cb9-245" aria-hidden="true" tabindex="-1"></a>        cutoff_frequency <span class="op">=</span> custom_cutoff_frequency</span>
<span id="cb9-246"><a href="#cb9-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-247"><a href="#cb9-247" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> input_type <span class="op">==</span> <span class="st">'ndarray'</span>:</span>
<span id="cb9-248"><a href="#cb9-248" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> custom_cutoff_frequency <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-249"><a href="#cb9-249" aria-hidden="true" tabindex="-1"></a>            _LOGGER.info(<span class="st">"Automatic cutoff estimation for </span><span class="sc">%d</span><span class="st"> channels (threshold=</span><span class="sc">%s%%</span><span class="st">)"</span>, data.shape[<span class="dv">1</span>], threshold)</span>
<span id="cb9-250"><a href="#cb9-250" aria-hidden="true" tabindex="-1"></a>            cutoff_frequencies <span class="op">=</span> [<span class="bu">float</span>(spectral_analysis(</span>
<span id="cb9-251"><a href="#cb9-251" aria-hidden="true" tabindex="-1"></a>                data<span class="op">=</span>column, sampling_freq<span class="op">=</span>sampling_freq, threshold<span class="op">=</span>threshold, plot<span class="op">=</span>plot)) <span class="cf">for</span> column <span class="kw">in</span> data.T]</span>
<span id="cb9-252"><a href="#cb9-252" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-253"><a href="#cb9-253" aria-hidden="true" tabindex="-1"></a>            cutoff_frequencies <span class="op">=</span> [cutoff_frequency] <span class="op">*</span> data.shape[<span class="dv">1</span>]</span>
<span id="cb9-254"><a href="#cb9-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-255"><a href="#cb9-255" aria-hidden="true" tabindex="-1"></a>        filtered_data <span class="op">=</span> np.array([apply_filter(column, cf)</span>
<span id="cb9-256"><a href="#cb9-256" aria-hidden="true" tabindex="-1"></a>                                 <span class="cf">for</span> column, cf <span class="kw">in</span> <span class="bu">zip</span>(data.T, cutoff_frequencies)]).T</span>
<span id="cb9-257"><a href="#cb9-257" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb9-258"><a href="#cb9-258" aria-hidden="true" tabindex="-1"></a>            cutoffs <span class="op">=</span> np.asarray(cutoff_frequencies, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb9-259"><a href="#cb9-259" aria-hidden="true" tabindex="-1"></a>            _LOGGER.info(</span>
<span id="cb9-260"><a href="#cb9-260" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Filtering complete for </span><span class="sc">%d</span><span class="st"> channels (butter_order=</span><span class="sc">%d</span><span class="st">). Cutoff summary: min=</span><span class="sc">%.3g</span><span class="st">Hz median=</span><span class="sc">%.3g</span><span class="st">Hz max=</span><span class="sc">%.3g</span><span class="st">Hz"</span>,</span>
<span id="cb9-261"><a href="#cb9-261" aria-hidden="true" tabindex="-1"></a>                cutoffs.size,</span>
<span id="cb9-262"><a href="#cb9-262" aria-hidden="true" tabindex="-1"></a>                butter_order,</span>
<span id="cb9-263"><a href="#cb9-263" aria-hidden="true" tabindex="-1"></a>                np.nanmin(cutoffs),</span>
<span id="cb9-264"><a href="#cb9-264" aria-hidden="true" tabindex="-1"></a>                np.nanmedian(cutoffs),</span>
<span id="cb9-265"><a href="#cb9-265" aria-hidden="true" tabindex="-1"></a>                np.nanmax(cutoffs),</span>
<span id="cb9-266"><a href="#cb9-266" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb9-267"><a href="#cb9-267" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb9-268"><a href="#cb9-268" aria-hidden="true" tabindex="-1"></a>            _LOGGER.info(<span class="st">"Filtering complete (ndarray input)."</span>)</span>
<span id="cb9-269"><a href="#cb9-269" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filtered_data</span>
<span id="cb9-270"><a href="#cb9-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-271"><a href="#cb9-271" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> input_type <span class="op">==</span> <span class="st">'dataframe'</span>:</span>
<span id="cb9-272"><a href="#cb9-272" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> custom_cutoff_frequency <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-273"><a href="#cb9-273" aria-hidden="true" tabindex="-1"></a>            _LOGGER.info(<span class="st">"Automatic cutoff estimation for </span><span class="sc">%d</span><span class="st"> channels (threshold=</span><span class="sc">%s%%</span><span class="st">)"</span>, <span class="bu">len</span>(data.columns), threshold)</span>
<span id="cb9-274"><a href="#cb9-274" aria-hidden="true" tabindex="-1"></a>            cutoff_frequencies <span class="op">=</span> {column: <span class="bu">float</span>(spectral_analysis(</span>
<span id="cb9-275"><a href="#cb9-275" aria-hidden="true" tabindex="-1"></a>                data<span class="op">=</span>data[column], sampling_freq<span class="op">=</span>sampling_freq, threshold<span class="op">=</span>threshold, plot<span class="op">=</span>plot)) <span class="cf">for</span> column <span class="kw">in</span> data.columns}</span>
<span id="cb9-276"><a href="#cb9-276" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-277"><a href="#cb9-277" aria-hidden="true" tabindex="-1"></a>            cutoff_frequencies <span class="op">=</span> {</span>
<span id="cb9-278"><a href="#cb9-278" aria-hidden="true" tabindex="-1"></a>                column: cutoff_frequency <span class="cf">for</span> column <span class="kw">in</span> data.columns}</span>
<span id="cb9-279"><a href="#cb9-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-280"><a href="#cb9-280" aria-hidden="true" tabindex="-1"></a>        filtered_data <span class="op">=</span> data.<span class="bu">apply</span>(<span class="kw">lambda</span> column: apply_filter(</span>
<span id="cb9-281"><a href="#cb9-281" aria-hidden="true" tabindex="-1"></a>            column, cutoff_frequencies[column.name]))</span>
<span id="cb9-282"><a href="#cb9-282" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb9-283"><a href="#cb9-283" aria-hidden="true" tabindex="-1"></a>            cutoffs <span class="op">=</span> np.asarray(<span class="bu">list</span>(cutoff_frequencies.values()), dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb9-284"><a href="#cb9-284" aria-hidden="true" tabindex="-1"></a>            _LOGGER.info(</span>
<span id="cb9-285"><a href="#cb9-285" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Filtering complete for </span><span class="sc">%d</span><span class="st"> channels (butter_order=</span><span class="sc">%d</span><span class="st">). Cutoff summary: min=</span><span class="sc">%.3g</span><span class="st">Hz median=</span><span class="sc">%.3g</span><span class="st">Hz max=</span><span class="sc">%.3g</span><span class="st">Hz"</span>,</span>
<span id="cb9-286"><a href="#cb9-286" aria-hidden="true" tabindex="-1"></a>                cutoffs.size,</span>
<span id="cb9-287"><a href="#cb9-287" aria-hidden="true" tabindex="-1"></a>                butter_order,</span>
<span id="cb9-288"><a href="#cb9-288" aria-hidden="true" tabindex="-1"></a>                np.nanmin(cutoffs),</span>
<span id="cb9-289"><a href="#cb9-289" aria-hidden="true" tabindex="-1"></a>                np.nanmedian(cutoffs),</span>
<span id="cb9-290"><a href="#cb9-290" aria-hidden="true" tabindex="-1"></a>                np.nanmax(cutoffs),</span>
<span id="cb9-291"><a href="#cb9-291" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb9-292"><a href="#cb9-292" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb9-293"><a href="#cb9-293" aria-hidden="true" tabindex="-1"></a>            _LOGGER.info(<span class="st">"Filtering complete (DataFrame input)."</span>)</span>
<span id="cb9-294"><a href="#cb9-294" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filtered_data</span>
<span id="cb9-295"><a href="#cb9-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-296"><a href="#cb9-296" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> input_type <span class="op">==</span> <span class="st">'series'</span>:</span>
<span id="cb9-297"><a href="#cb9-297" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> custom_cutoff_frequency <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-298"><a href="#cb9-298" aria-hidden="true" tabindex="-1"></a>            cutoff_frequency <span class="op">=</span> <span class="bu">float</span>(spectral_analysis(</span>
<span id="cb9-299"><a href="#cb9-299" aria-hidden="true" tabindex="-1"></a>                data<span class="op">=</span>data, sampling_freq<span class="op">=</span>sampling_freq, threshold<span class="op">=</span>threshold, plot<span class="op">=</span>plot))</span>
<span id="cb9-300"><a href="#cb9-300" aria-hidden="true" tabindex="-1"></a>        filtered_data <span class="op">=</span> apply_filter(data, cutoff_frequency)</span>
<span id="cb9-301"><a href="#cb9-301" aria-hidden="true" tabindex="-1"></a>        _LOGGER.info(<span class="st">"Filtering complete for 1 channel (butter_order=</span><span class="sc">%d</span><span class="st">). Cutoff=</span><span class="sc">%.3g</span><span class="st"> Hz"</span>, butter_order, cutoff_frequency)</span>
<span id="cb9-302"><a href="#cb9-302" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pd.Series(filtered_data, index<span class="op">=</span>data.index, name<span class="op">=</span>data.name)</span>
<span id="cb9-303"><a href="#cb9-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-304"><a href="#cb9-304" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> input_type <span class="op">==</span> <span class="st">'list'</span>:</span>
<span id="cb9-305"><a href="#cb9-305" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Treat as 1D array</span></span>
<span id="cb9-306"><a href="#cb9-306" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> custom_cutoff_frequency <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-307"><a href="#cb9-307" aria-hidden="true" tabindex="-1"></a>            cutoff_frequency <span class="op">=</span> <span class="bu">float</span>(spectral_analysis(</span>
<span id="cb9-308"><a href="#cb9-308" aria-hidden="true" tabindex="-1"></a>                data<span class="op">=</span>data, sampling_freq<span class="op">=</span>sampling_freq, threshold<span class="op">=</span>threshold, plot<span class="op">=</span>plot))</span>
<span id="cb9-309"><a href="#cb9-309" aria-hidden="true" tabindex="-1"></a>        filtered_data <span class="op">=</span> apply_filter(pd.Series(data), cutoff_frequency)</span>
<span id="cb9-310"><a href="#cb9-310" aria-hidden="true" tabindex="-1"></a>        _LOGGER.info(<span class="st">"Filtering complete for 1 channel (butter_order=</span><span class="sc">%d</span><span class="st">). Cutoff=</span><span class="sc">%.3g</span><span class="st"> Hz"</span>, butter_order, cutoff_frequency)</span>
<span id="cb9-311"><a href="#cb9-311" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filtered_data.tolist()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="synthetic-signal-demo-what-to-look-for" class="level3">
<h3 class="anchored" data-anchor-id="synthetic-signal-demo-what-to-look-for">Synthetic signal demo — what to look for</h3>
<p>This cell creates a noisy sine wave and demonstrates the effect of different low-pass cutoffs.</p>
<p>Learning points: - How lowpass filtering progressively removes higher frequency content as the cutoff decreases. - What over‑smoothing looks like (important features removed) vs under‑filtering (noise remains). - The importance of choosing a cutoff relative to the signal’s content (here a 20 Hz sine wave).</p>
<div id="b5c87774" class="cell" data-execution_count="77">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the original signal parameters</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>sampling_rate <span class="op">=</span> <span class="dv">1000</span>  <span class="co"># Hz</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>duration <span class="op">=</span> <span class="fl">0.5</span>  <span class="co"># seconds</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>frequency <span class="op">=</span> <span class="dv">20</span>  <span class="co"># Hz</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>amplitude <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># Amplitude of the sine wave</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>noise_level <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># Amplitude of the noise</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate time vector</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> np.linspace(<span class="dv">0</span>, duration, <span class="bu">int</span>(sampling_rate <span class="op">*</span> duration), endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create sine wave</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>sine_wave <span class="op">=</span> amplitude <span class="op">*</span> np.sin(<span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> frequency <span class="op">*</span> time)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate noise</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> noise_level<span class="op">*</span>np.random.uniform(<span class="bu">min</span>(sine_wave), <span class="bu">max</span>(sine_wave), <span class="bu">len</span>(time))</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Add noise to sine wave</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>noisy_signal <span class="op">=</span> sine_wave <span class="op">+</span> noise</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Define cutoff frequencies to demonstrate aliasing</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>cutoff_frequencies <span class="op">=</span> [<span class="dv">400</span>, <span class="dv">200</span>, <span class="dv">40</span>, <span class="dv">10</span>]  <span class="co"># Hz, progressively lower</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lowpass_filter(data, cutoff_freq, sampling_rate, order<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Applies a low-pass Butterworth filter to the input data."""</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    nyquist_freq <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> sampling_rate</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    normalized_cutoff <span class="op">=</span> cutoff_freq <span class="op">/</span> nyquist_freq</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    b, a <span class="op">=</span> butter(N<span class="op">=</span><span class="dv">4</span>, Wn<span class="op">=</span>cutoff_freq,</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>                      btype<span class="op">=</span><span class="st">"low"</span>, fs<span class="op">=</span>sampling_rate, output<span class="op">=</span><span class="st">"ba"</span>)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> filtfilt(b, a, data)</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, fc <span class="kw">in</span> <span class="bu">enumerate</span>(cutoff_frequencies, <span class="dv">1</span>):</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    filtered_signal <span class="op">=</span> lowpass_filter(noisy_signal, fc, sampling_rate)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot results</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="bu">len</span>(cutoff_frequencies), <span class="dv">1</span>, i)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    plt.plot(time, sine_wave, color<span class="op">=</span><span class="st">'tab:blue'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="st">"Original Sine Wave"</span>)</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    plt.plot(time, noisy_signal, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">"Noisy Signal"</span>)</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>    plt.plot(time, filtered_signal, color<span class="op">=</span><span class="st">'tab:orange'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="ss">f"Filtered at </span><span class="sc">{</span>fc<span class="sc">}</span><span class="ss">Hz"</span>,)</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Position legend to the right</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>    plt.legend(loc<span class="op">=</span><span class="st">'center left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">1</span>, <span class="fl">0.5</span>))</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Time (s)"</span>)</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"Filtered with </span><span class="sc">{</span>fc<span class="sc">}</span><span class="ss">Hz cutoff frequency"</span>)</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="BalanceSignalProcessingTutorial_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="interactive-slider-how-to-use-and-what-to-observe" class="level3">
<h3 class="anchored" data-anchor-id="interactive-slider-how-to-use-and-what-to-observe">Interactive slider — how to use and what to observe</h3>
<p>This widget allows you to pick a manual cutoff frequency and immediately see its impact on the filtered voltage signals.</p>
<p>Learning points: - Observe how the traces become smoother as cutoff decreases and how details are lost when the cutoff is set too low. - Note the update time: filtering multiple channels may take a few seconds after moving the slider. - Use this tool to develop an intuition for a reasonable range of cutoff frequencies before using data-driven spectral methods.</p>
<div id="55fe7765" class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the slider to see how using different cutoff frequencies effects the signal</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>cutoff_freq <span class="op">=</span> ipywidgets.widgets.FloatSlider(value<span class="op">=</span><span class="dv">25</span>, <span class="bu">min</span><span class="op">=</span><span class="fl">0.1</span>, <span class="bu">max</span><span class="op">=</span><span class="fl">49.9</span>, step<span class="op">=</span><span class="fl">0.1</span>, description<span class="op">=</span><span class="st">'Cutoff Frequency (Hz):'</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> filter_and_plot(cutoff_freq):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  filtered_data_EO <span class="op">=</span> filter_timeseries_data(df_EO, <span class="dv">100</span>, custom_cutoff_frequency<span class="op">=</span>cutoff_freq, plot<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  filtered_data_EC <span class="op">=</span> filter_timeseries_data(df_EC, <span class="dv">100</span>, custom_cutoff_frequency<span class="op">=</span>cutoff_freq, plot<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  plot_voltage_data(filtered_data_EO, filtered_data_EC, time_range<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">15</span>), figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), dpi<span class="op">=</span><span class="dv">100</span>, pad<span class="op">=</span><span class="fl">2.0</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> ipywidgets.interactive_output(filter_and_plot, {<span class="st">'cutoff_freq'</span>: cutoff_freq})</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Note: it may take a minute for the plot to update after moving the slider"</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>display(cutoff_freq, out)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Note: it may take a minute for the plot to update after moving the slider</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"d0b61ba32739473db49fc00f07c2ea9d","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"9f249385b2224a52b6201c7021c767e0","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
</section>
<section id="choosing-a-cumulative-power-threshold" class="level3">
<h3 class="anchored" data-anchor-id="choosing-a-cumulative-power-threshold">Choosing a cumulative power threshold</h3>
<p>To derive a data‑driven low‑pass cutoff, we find the frequency where the PSD cumulative power reaches a chosen percentage of total power (typical: 95–99%). This balances keeping sway-related energy and rejecting high‑frequency noise.</p>
<p>Rules of thumb - 95% is a practical starting point for many signals; 99% is more conservative (keeps more high‑frequency content). - Avoid extreme values: too low (e.g., &lt;90%) can remove meaningful data; attempting to use 100% can include noise and numerical edge cases.</p>
<p>Diagnostics - Always inspect the PSD and the cumulative power plot together. The chosen cutoff should fall after the dominant low‑frequency peaks but before the broadband noise floor grows. - If the cumulative curve has no clear knee, compare several representative channels and pick a conservative compromise or use manual inspection.</p>
<p>Practical steps 1. Try 95% and visually inspect filtered traces versus raw traces. 2. If excessive smoothing occurs, raise toward 97–99% and re-evaluate.</p>
<p>Interactive use - The threshold slider in the notebook lets you explore how thresholds change the estimated cutoff and filtered results; use the PSD diagnostics (<code>plot=True</code>) to justify your selection.</p>
<p>Takeaway: pick a threshold grounded in both the quantitative cumulative-power metric and the visual appearance of filtered traces — document the exact threshold in your analysis.</p>
<div id="96025394" class="cell" data-execution_count="79">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> filter_and_plot(threshold):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter the EO and EC data using the selected cutoff frequency</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    df_EC_filtered <span class="op">=</span> filter_timeseries_data(df_EC[[<span class="st">'VFz'</span>]], <span class="dv">100</span>, custom_cutoff_frequency<span class="op">=</span><span class="va">None</span>, threshold<span class="op">=</span>threshold, plot<span class="op">=</span><span class="va">True</span>, nan_policy<span class="op">=</span><span class="st">'interpolate'</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create two separate figures for EO and EC data</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    figsize <span class="op">=</span> (<span class="dv">12</span>, <span class="dv">6</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    time_range <span class="op">=</span> (<span class="dv">15</span>, <span class="dv">30</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    time <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="bu">len</span>(df_EC_filtered)<span class="op">/</span><span class="dv">100</span>, <span class="bu">len</span>(df_EC_filtered))</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    pad <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    fig_EC, axs_EC <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>figsize)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot EO data</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    col, title <span class="op">=</span> (<span class="st">'VFz'</span>,<span class="st">'Fz voltage'</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    axs_EC.plot(time, df_EC[[<span class="st">'VFz'</span>]], color<span class="op">=</span><span class="st">'tab:blue'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="st">'EO - Original'</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    axs_EC.plot(time, df_EC_filtered, color<span class="op">=</span><span class="st">'tab:orange'</span>, label<span class="op">=</span><span class="st">'EO - Filtered'</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    axs_EC.legend(bbox_to_anchor<span class="op">=</span>(<span class="fl">1.1</span>, <span class="dv">1</span>), loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    axs_EC.set_title(title)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    axs_EC.set_xlim(time_range)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set x-axis labels and limits</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    axs_EC.set_xlabel(<span class="st">'Time [s]'</span>)</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set y-axis label for the middle subplot in both figures</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    axs_EC.set_ylabel(<span class="st">'Voltage [V]'</span>)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    fig_EC.align_ylabels()</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adjust layout for both figures</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout(pad<span class="op">=</span>pad)</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adjust the layouts to avoid overlap with legends and titles</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    plt.subplots_adjust(top<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    fig_EC.subplots_adjust(top<span class="op">=</span><span class="fl">0.9</span>)</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    fig_EC.suptitle(<span class="st">'Eyes Open Data'</span>)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show plot</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a slider for cutoff frequency</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>threshold_slider <span class="op">=</span> widgets.FloatSlider(value<span class="op">=</span><span class="dv">50</span>, <span class="bu">min</span><span class="op">=</span><span class="dv">1</span>, <span class="bu">max</span><span class="op">=</span><span class="fl">99.9</span>, step<span class="op">=</span><span class="fl">0.1</span>, description<span class="op">=</span><span class="st">'Power:'</span>)</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an interactive widget</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>interactive_plot <span class="op">=</span> widgets.interactive_output(filter_and_plot, {<span class="st">'threshold'</span>: threshold_slider})</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the slider and the plot</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Note: it may take a minute for the plot to update after moving the slider"</span>)</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>display(threshold_slider, interactive_plot), </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Note: it may take a minute for the plot to update after moving the slider</code></pre>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"d56ed0debf394ce496d6186f3e6910a9","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"3a69a30b946943abb01fcac708ae329e","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display" data-execution_count="79">
<pre><code>(None,)</code></pre>
</div>
</div>
</section>
<section id="convert-measured-voltages-to-forces-and-moments" class="level2">
<h2 class="anchored" data-anchor-id="convert-measured-voltages-to-forces-and-moments">Convert measured voltages to forces and moments</h2>
<p>This section shows how to convert the six measured channel voltages from the force plate into physical forces and moments. We provide the inverted sensitivity matrix (B), the amplifier gain (G), and the input voltage (V_0). The conversion is applied row-wise and vectorized in the code cells that follow.</p>
<p>What this section does - Converts raw channel voltages <span class="math inline">\((V_{Fx}, V_{Fy}, V_{Fz}, V_{Mx}, V_{My}, V_{Mz})\)</span> → forces/moments <span class="math inline">\((F_x, F_y, F_z, M_x, M_y, M_z)\)</span> in SI units. - Stores results as new columns in the existing dataframes for use in plotting and analysis.</p>
<p>Formula (applied per time-point):</p>
<p><span class="math display">\[\vec{Y} = \frac{10^6}{G V_0} \vec{V} B^T\]</span></p>
<p>Where: - (<span class="math inline">\(\vec{V}\)</span>) is the 1×6 voltage row vector at a time point. - (<span class="math inline">\(B\)</span>) is the inverted sensitivity matrix (6×6) shown below. - The factor <span class="math inline">\(10^6\)</span> adjusts from volts/millivolts depending on your amplifier/device calibration (kept here to match the provided calibration constants).</p>
<p>Verification checks (quick ideas) - Compare the mean of the vertical force (<span class="math inline">\(F_z\)</span>) to the subject’s body weight (mass × 9.81 m/s²) — they should be close on average. - Plot raw voltages vs computed forces for one channel to confirm linear scaling. - Check for unreasonable outliers in computed forces (e.g., extremely large or NaN values) and investigate missing/erroneous voltage samples.</p>
<p>Units and scaling notes - Make sure the amplifier gain (<span class="math inline">\(G\)</span>) and the input voltage (<span class="math inline">\(V_0\)</span>) reflect your acquisition hardware. If your device uses millivolt outputs with a different amplifier gain, adjust the conversion factor accordingly. - Document the units (N, N·m) and any scaling factors in your analysis record so others can reproduce your results.</p>
<p>Tips - Keep the original voltage columns until you are comfortable with the conversion. The notebook already assigns new columns <code>Fx, Fy, Fz, Mx, My, Mz</code> to <code>df_EO</code> and <code>df_EC</code>. - If units or calibration constants differ for your dataset, update <span class="math inline">\(G\)</span>, <span class="math inline">\(V_0\)</span>, or <span class="math inline">\(B\)</span> accordingly and re-run the conversion cell.</p>
<p>What’s next - After conversion, visualize the force and moment time-series and inspect their PSDs to plan appropriate cutoffs for filtering.</p>
<div id="05bc4f50" class="cell" data-execution_count="80">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inverted sensitivity matrix, B</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.array([</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">2.9007</span>,  <span class="fl">0.0200</span>, <span class="op">-</span><span class="fl">0.0009</span>, <span class="op">-</span><span class="fl">0.0253</span>, <span class="op">-</span><span class="fl">0.0085</span>,  <span class="fl">0.0090</span>],</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.0067</span>, <span class="fl">2.9024</span>, <span class="op">-</span><span class="fl">0.0520</span>, <span class="op">-</span><span class="fl">0.0366</span>, <span class="op">-</span><span class="fl">0.0149</span>, <span class="op">-</span><span class="fl">0.0341</span>],</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.0046</span>, <span class="op">-</span><span class="fl">0.0229</span>, <span class="fl">11.4206</span>, <span class="op">-</span><span class="fl">0.0055</span>,  <span class="fl">0.0055</span>,  <span class="fl">0.0026</span>],</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    [<span class="op">-</span><span class="fl">0.0019</span>,  <span class="fl">0.0035</span>, <span class="op">-</span><span class="fl">0.0067</span>,  <span class="fl">1.4559</span>, <span class="op">-</span><span class="fl">0.0053</span>, <span class="op">-</span><span class="fl">0.0028</span>],</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.0036</span>,  <span class="fl">0.0011</span>, <span class="op">-</span><span class="fl">0.0067</span>,  <span class="fl">0.0018</span>,  <span class="fl">1.1475</span>, <span class="op">-</span><span class="fl">0.0008</span>],</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.0037</span>,  <span class="fl">0.0145</span>, <span class="op">-</span><span class="fl">0.0032</span>,  <span class="fl">0.0006</span>,  <span class="fl">0.0076</span>,  <span class="fl">0.6188</span>]</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> <span class="dv">4000</span> <span class="co"># Gain</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>V_0 <span class="op">=</span> <span class="dv">10</span> <span class="co"># Input voltage</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>CF <span class="op">=</span> <span class="fl">1e6</span><span class="op">/</span>(G<span class="op">*</span>V_0) <span class="co"># Conversion factor</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="afc930e1" class="cell" data-execution_count="81">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting function</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_data(df_EO, df_EC, df_cols, plot_titles, y_labels, time_range<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">30</span>), figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>), dpi<span class="op">=</span><span class="dv">200</span>, pad<span class="op">=</span><span class="fl">2.0</span>):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Plot signals from two dataframes (EO and EC) over a specified time range.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">    This function generates six subplots corresponding to force (Fx, Fy, Fz) and moment (Mx, My, Mz) signals,</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">    comparing data from two different conditions (EO and EC).</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">        df_EO (DataFrame): Data containing EO (Eyes Open) condition.</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">        df_EC (DataFrame): Data containing EC (Eyes Closed) condition, with the same columns as df_EO.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">        df_cols (list): List of column names to plot from the dataframes.</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">        plot_titles (list): List of titles for each subplot.</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">        y_labels (list): List of y-axis labels for each subplot.</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co">        time_range (tuple, optional): Time range (start, end) in seconds for plotting. Defaults to (15, 30).</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co">        figsize (tuple, optional): Figure size as (width, height). Defaults to (10, 8).</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">        dpi (int, optional): Dots per inch (DPI) setting for the figure resolution. Defaults to 200.</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co">        pad (float, optional): Padding for tight_layout to adjust subplot spacing. Defaults to 2.0.</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises:</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError: If the input dataframes do not contain the required columns.</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; plot_data(df_EO, df_EC, ['Fx', 'Fy', 'Fz', 'Mx', 'My', 'Mz'], titles, labels, time_range=(10, 25))</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create subplots</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    fig, axs <span class="op">=</span> plt.subplots(<span class="dv">6</span>, <span class="dv">1</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">False</span>, dpi<span class="op">=</span>dpi, figsize<span class="op">=</span>figsize)</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot data for each subplot</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (col, title, y_label) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(df_cols,</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>                                         plot_titles,y_labels)):</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>        axs[i].plot(df_EO[<span class="st">'Time'</span>], df_EO[col], color<span class="op">=</span><span class="st">'tab:blue'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="st">'EO'</span>)</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>        axs[i].plot(df_EC[<span class="st">'Time'</span>], df_EC[col], color<span class="op">=</span><span class="st">'tab:orange'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="st">'EC'</span>)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>        axs[i].legend(bbox_to_anchor<span class="op">=</span>(<span class="fl">1.1</span>, <span class="dv">1</span>), loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        axs[i].set_ylabel(y_label)</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>        axs[i].set_title(title)</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set x-axis label and limits</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Time [s]'</span>)</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>    plt.xlim(time_range)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adjust layout</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout(pad<span class="op">=</span>pad)</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show the plot</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div id="3093ec0d" class="cell" data-execution_count="82">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get voltages as array-like</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>V_EO <span class="op">=</span> df_EO[[<span class="st">'VFx'</span>, <span class="st">'VFy'</span>, <span class="st">'VFz'</span>, <span class="st">'VMx'</span>, <span class="st">'VMy'</span>, <span class="st">'VMz'</span>]].to_numpy()</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute forces and moments in a vectorized manner</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>Y_EO <span class="op">=</span> CF<span class="op">*</span>(V_EO<span class="op">@</span>B.T)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign computed values back to DataFrame</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>df_EO[[<span class="st">'Fx'</span>, <span class="st">'Fy'</span>, <span class="st">'Fz'</span>, <span class="st">'Mx'</span>, <span class="st">'My'</span>, <span class="st">'Mz'</span>]] <span class="op">=</span> Y_EO</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Get voltages as array-like</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>V_EC <span class="op">=</span> df_EC[[<span class="st">'VFx'</span>, <span class="st">'VFy'</span>, <span class="st">'VFz'</span>, <span class="st">'VMx'</span>, <span class="st">'VMy'</span>, <span class="st">'VMz'</span>]].to_numpy()</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute forces and moments in a vectorized manner</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>Y_EC <span class="op">=</span> CF<span class="op">*</span>(V_EC<span class="op">@</span>B.T)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign computed values back to DataFrame</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>df_EC[[<span class="st">'Fx'</span>, <span class="st">'Fy'</span>, <span class="st">'Fz'</span>, <span class="st">'Mx'</span>, <span class="st">'My'</span>, <span class="st">'Mz'</span>]] <span class="op">=</span> Y_EC</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>Y_cols <span class="op">=</span> [<span class="st">'Fx'</span>,<span class="st">'Fy'</span>,<span class="st">'Fz'</span>,<span class="st">'Mx'</span>,<span class="st">'My'</span>,<span class="st">'Mz'</span>]</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>plot_titles <span class="op">=</span> [<span class="st">'Fx'</span>,<span class="st">'Fy'</span>,<span class="st">'Fz'</span>,<span class="st">'Mx'</span>,<span class="st">'My'</span>,<span class="st">'Mz'</span>]</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>y_labels <span class="op">=</span> [<span class="st">'$F_x$ [N]'</span>,<span class="st">'$F_y$ [N]'</span>,<span class="st">'$F_z$ [N]'</span>,<span class="st">'$M_x$ [N-m]'</span>,<span class="st">'$M_y$ [N-m]'</span>,<span class="st">'$M_z$ [N-m]'</span>]</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>plot_data(df_EO<span class="op">=</span>df_EO,df_EC<span class="op">=</span>df_EC,df_cols<span class="op">=</span>Y_cols,plot_titles<span class="op">=</span>plot_titles,y_labels<span class="op">=</span>y_labels,time_range<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">15</span>),dpi<span class="op">=</span><span class="dv">100</span>,figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">8</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="BalanceSignalProcessingTutorial_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="filtering-and-selecting-cutoff-frequencies-practical-guide" class="level2">
<h2 class="anchored" data-anchor-id="filtering-and-selecting-cutoff-frequencies-practical-guide">Filtering and selecting cutoff frequencies — practical guide</h2>
<p>This section demonstrates how different low-pass cutoff choices affect moment signals and how to apply a zero-phase Butterworth filter to all force/moment channels.</p>
<p>What you’ll see - Example plots that compare a too-low cutoff (over‑smoothed), a too-high cutoff (insufficient noise removal), and a data-driven cutoff determined via cumulative power from the PSD. - Code that uses <code>filter_timeseries_data(...)</code> to compute per-channel cutoffs (or accept a single custom cutoff) and perform zero‑phase filtering with <code>filtfilt</code> when possible.</p>
<p>How to choose cutoffs - Too low: removes physiologically relevant sway (underestimates variability). - Too high: keeps noise that inflates spectral/variance metrics. - Data-driven: compute cutoff from a chosen cumulative power threshold (e.g., 95–99%). Use <code>spectral_analysis(..., threshold=...)</code> to inspect PSD/cumulative plots and select a threshold.</p>
<p>Recommended filtering workflow (concise) 1. Compute PSD and cumulative power for a representative segment of each channel. 2. Pick a threshold (start at 95%), compute cutoff per channel, and inspect a few filtered traces. 3. If multiple channels consistently suggest similar cutoffs, you may choose to use a common cutoff for simplicity; otherwise preserve per-channel cutoffs. 4. Apply filtering to the full dataset and save the cutoffs used alongside filtered outputs.</p>
<p>Common practical options - Notch filtering: if mains interference (50/60 Hz) is present and strong, consider a narrow notch filter before low-pass filtering. - Detrending: remove linear drift before PSD computation if low-frequency trends dominate the spectrum. - Short recordings: filtfilt padding rules may not be satisfied; the function falls back to <code>lfilter</code> — document this and avoid phase-sensitive measures in that case.</p>
<p>Checking results - Plot raw vs filtered traces and quantize differences (RMS reduction) to ensure you’re not removing expected signal content. - Compare sway metrics (range, speed) before and after filtering to understand the filter’s impact.</p>
<p>Tip - Save per-channel cutoff frequencies (and the threshold used to compute them) in a small JSON or CSV so your analysis is reproducible.</p>
<div id="991cc110" class="cell" data-execution_count="84">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create shortened df to only include signals between 15 and 30 seconds...</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>f_c1_EC <span class="op">=</span> <span class="fl">0.5</span> <span class="co"># (Hz) Too low cutoff frequency</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>f_c2_EC <span class="op">=</span> <span class="dv">450</span> <span class="co"># (Hz) Too high cutoff frequency</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>fs <span class="op">=</span> <span class="dv">1000</span> <span class="co"># ENSURE THAT THIS MATCHES THE DATA SAMPLING RATE!</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>f_c3_EC <span class="op">=</span> spectral_analysis(df_EC[<span class="st">'My'</span>],sampling_freq<span class="op">=</span>fs, threshold<span class="op">=</span><span class="dv">95</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">type</span>(pd.DataFrame(df_EC[<span class="st">'My'</span>])))</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter data using too low of a cutoff frequency</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>df_c1 <span class="op">=</span> filter_timeseries_data(pd.DataFrame(df_EC[<span class="st">'My'</span>]),sampling_freq<span class="op">=</span>fs,custom_cutoff_frequency<span class="op">=</span>f_c1_EC)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter data using too high of a cutoff frequency</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>df_c2 <span class="op">=</span> filter_timeseries_data(pd.DataFrame(df_EC[<span class="st">'My'</span>]),sampling_freq<span class="op">=</span>fs,custom_cutoff_frequency<span class="op">=</span>f_c2_EC)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter data using an appropriate cutoff frequency</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>df_c3 <span class="op">=</span> filter_timeseries_data(pd.DataFrame(df_EC[<span class="st">'My'</span>]),sampling_freq<span class="op">=</span>fs,custom_cutoff_frequency<span class="op">=</span>f_c3_EC)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the data showing the effects of using the different cutoff frequencies</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">False</span>, dpi<span class="op">=</span><span class="dv">100</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> df_EC[<span class="st">'Time'</span>]</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Subplot 1: too low cutoff</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(time, df_EC[<span class="st">'My'</span>], color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="st">'Original $M_y$ (raw)'</span>)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(time, df_c1[<span class="st">'My'</span>], color<span class="op">=</span><span class="st">'tab:blue'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="ss">f'Filtered (fc=</span><span class="sc">{</span>f_c1_EC<span class="sc">:.2f}</span><span class="ss"> Hz)'</span>)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">"Cutoff Freq Too Low"</span>)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].legend(loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Subplot 2: too high cutoff</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].plot(time, df_EC[<span class="st">'My'</span>], color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="st">'Original $M_y$ (raw)'</span>)</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].plot(time, df_c2[<span class="st">'My'</span>], color<span class="op">=</span><span class="st">'tab:green'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="ss">f'Filtered (fc=</span><span class="sc">{</span>f_c2_EC<span class="sc">:.2f}</span><span class="ss"> Hz)'</span>)</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="st">"Cutoff Freq Too High"</span>)</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].legend(loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Subplot 3: appropriate cutoff (data-driven)</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">2</span>].plot(time, df_EC[<span class="st">'My'</span>], color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>, label<span class="op">=</span><span class="st">'Original $M_y$ (raw)'</span>)</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">2</span>].plot(time, df_c3[<span class="st">'My'</span>], color<span class="op">=</span><span class="st">'tab:orange'</span>, alpha<span class="op">=</span><span class="fl">1.0</span>, label<span class="op">=</span><span class="ss">f'Filtered (fc=</span><span class="sc">{</span>f_c3_EC<span class="sc">:.2f}</span><span class="ss"> Hz)'</span>)</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">2</span>].set_title(<span class="st">"Appropriate Cutoff Frequency (spectral_analysis)"</span>)</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">2</span>].legend(loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>axs[<span class="op">-</span><span class="dv">1</span>].set_xlabel(<span class="st">'Time [s]'</span>)</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylabel(<span class="st">'Eyes Closed $M_y$ [N-m]'</span>)</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Zoom to the 15-30 s window as intended (if available)</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>].set_xlim(<span class="dv">5</span>, <span class="dv">15</span>)</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span>:</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(pad<span class="op">=</span><span class="fl">2.0</span>)</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>df_EO_filtered <span class="op">=</span> filter_timeseries_data(df_EO, sampling_freq<span class="op">=</span>fs)</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>df_EC_filtered <span class="op">=</span> filter_timeseries_data(df_EC, sampling_freq<span class="op">=</span>fs)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="BalanceSignalProcessingTutorial_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="center-of-pressure-cop-calculation-and-stabilogram-plotting" class="level2">
<h2 class="anchored" data-anchor-id="center-of-pressure-cop-calculation-and-stabilogram-plotting">Center of Pressure (CoP) — calculation and stabilogram plotting</h2>
<p>This section explains what the Center of Pressure (CoP) is, why it matters for balance analysis, how to compute it from filtered force/moment signals, and how to visualize stabilograms for EO and EC conditions.</p>
<p>What is the CoP? - The CoP is the point location on the force‑plate surface where the resultant ground reaction force acts. It is computed from vertical force and plate moments and represents the net pressure centroid under the foot/feet. - Physically, CoP tracks how the neuromuscular system shifts load to maintain balance; it is a directly measured, high‑temporal‑resolution proxy for postural control dynamics. - CoP is not the same as the body Center of Mass (CoM). CoM represents mass distribution of the body and typically requires motion capture and modeling; CoP is measured directly by the force plate.</p>
<p>Why CoP is useful - Sensitive to corrective actions: fast corrective sways and stabilizing adjustments produce characteristic CoP excursions and velocities. - Trial‑level and summary metrics derived from CoP (range, speed, excursion) are widely used to quantify postural stability and to compare conditions or groups (e.g., EO vs EC). - Easy to compute and reproducible across labs when calibration and filtering are documented.</p>
<p>What is a stabilogram? - A stabilogram is a 2D time‑series plot of CoP coordinates (ML vs AP) that shows the trajectory of CoP over the trial. It is the primary visualization for postural sway. - Interpret visually: - Large cloud/trajectory = more sway / less stability. - Long, smooth excursions suggest slow drift; dense, jittery paths indicate higher-frequency corrective actions or noise. - Complement stabilograms with scalar summaries (range, mean speed, RMS) and spectral analysis to separate slow and fast behavior.</p>
<p>Computation (per time point):</p>
<ul>
<li>Given the measured vector <span class="math inline">\(\vec{Y} = (F_x, F_y, F_z, M_x, M_y, M_z)\)</span> and the plate shear‑center offset <span class="math inline">\(z_0\)</span> (in meters), the CoP coordinates are computed as the displayed equations:</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\vec{Y} &amp;= \big(F_x,\, F_y,\, F_z,\, M_x,\, M_y,\, M_z\big) \\
x_{\mathrm{CoP}} &amp;= \frac{M_x + z_0\,F_y}{F_z} \\[6pt]
y_{\mathrm{CoP}} &amp;= \frac{z_0\,F_x - M_y}{F_z}
\end{aligned}
\]</span></p>
<ul>
<li>Important notes on signs and conventions: confirm that your plate calibration and sign convention match these formulas (Mx positive → generates positive x_CoP, etc.). Small sign flips in moments/forces will invert CoP axes.</li>
</ul>
<p>Units and centering - Keep consistent SI units: forces in N, moments in N·m, z0 in m. Convert CoP from meters to mm for plotting (multiply by 1e3) if desired for readability. - Center stabilograms by subtracting the temporal mean from each CoP axis so the trajectory is centered at (0,0). This removes constant offsets due to subject placement.</p>
<p>Practical tips and pitfalls - Handle small/zero Fz: mask, drop, or interpolate samples where Fz is near zero (division by very small values yields spurious large CoP). Consider thresholding Fz (e.g., ignore samples where Fz &lt; some small fraction of median Fz). - Filtering: compute CoP from filtered forces/moments (zero‑phase filtering preferred) to avoid adding high‑frequency noise in the stabilogram. Document filter design (type, order, cutoff). - Edge effects: filtfilt requires adequate padding—short recordings may fall back to lfilter (phase shift). Avoid phase‑sensitive measures if filtfilt fallback occurs. - Outlier checks: clip or remove sudden CoP spikes due to artifacts (e.g., transient force clipping).</p>
<p>Plotting guidance - Use equal axis scales (square aspect ratio) and identical axis limits for EO and EC to allow direct visual comparison. - Add dashed lines at zero to show anatomical midlines; annotate mean CoP and origin. - For long traces, consider color‑coding by time, plotting a density/contour, or downsampling for clarity. - Overlay raw vs filtered CoP (or show both on separate panels) to confirm filtering did not remove relevant low‑frequency features.</p>
<p>Interpretation (tandem stance example) - Tandem stance typically increases AP sway (narrow fore‑aft base) and may increase average CoP speed; removing vision (EC) commonly further increases excursion and speed. - Use paired comparisons (EO vs EC) and percent change together with stabilograms to report effects.</p>
<p>Next steps - Compute scalar metrics from the centered CoP (AP/ML excursion ranges, mean CoP speed, mean excursion distance, std dev) and report the filter/cutoff and any sample masking thresholds used for reproducibility. - Important notes on signs and conventions: confirm that your plate calibration and sign convention match these formulas (Mx positive → generates positive x_CoP, etc.). Small sign flips in moments/forces will invert CoP axes.</p>
<p>Units and centering - Keep consistent SI units: forces in N, moments in N·m, z0 in m. Convert CoP from meters to mm for plotting (multiply by 1e3) if desired for readability. - Center stabilograms by subtracting the temporal mean from each CoP axis so the trajectory is centered at (0,0). This removes constant offsets due to subject placement.</p>
<p>Practical tips and pitfalls - Handle small/zero Fz: mask, drop, or interpolate samples where Fz is near zero (division by very small values yields spurious large CoP). Consider thresholding Fz (e.g., ignore samples where Fz &lt; some small fraction of median Fz). - Filtering: compute CoP from filtered forces/moments (zero‑phase filtering preferred) to avoid adding high‑frequency noise in the stabilogram. Document filter design (type, order, cutoff). - Edge effects: filtfilt requires adequate padding—short recordings may fall back to lfilter (phase shift). Avoid phase‑sensitive measures if filtfilt fallback occurs. - Outlier checks: clip or remove sudden CoP spikes due to artifacts (e.g., transient force clipping).</p>
<p>Plotting guidance - Use equal axis scales (square aspect ratio) and identical axis limits for EO and EC to allow direct visual comparison. - Add dashed lines at zero to show anatomical midlines; annotate mean CoP and origin. - For long traces, consider color‑coding by time, plotting a density/contour, or downsampling for clarity. - Overlay raw vs filtered CoP (or show both on separate panels) to confirm filtering did not remove relevant low‑frequency features.</p>
<p>Interpretation (tandem stance example) - Tandem stance typically increases AP sway (narrow fore‑aft base) and may increase average CoP speed; removing vision (EC) commonly further increases excursion and speed. - Use paired comparisons (EO vs EC) and percent change together with stabilograms to report effects.</p>
<p>Next steps - Compute scalar metrics from the centered CoP (AP/ML excursion ranges, mean CoP speed, mean excursion distance, std dev) and report the filter/cutoff and any sample masking thresholds used for reproducibility.</p>
<div id="29054580" class="cell" data-execution_count="85">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>z_0 <span class="op">=</span> <span class="op">-</span><span class="fl">37.645</span><span class="op">*</span><span class="fl">1e-3</span> <span class="co"># (m) Shear center relative to geometric center</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>COPx_EO <span class="op">=</span> (df_EO_filtered[<span class="st">'Mx'</span>]<span class="op">+</span>z_0<span class="op">*</span>df_EO_filtered[<span class="st">'Fy'</span>])<span class="op">/</span>df_EO_filtered[<span class="st">'Fz'</span>]</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>COPy_EO <span class="op">=</span> (df_EO_filtered[<span class="st">'My'</span>]<span class="op">-</span>z_0<span class="op">*</span>df_EO_filtered[<span class="st">'Fx'</span>])<span class="op">/</span>df_EO_filtered[<span class="st">'Fz'</span>]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>COPx_EC <span class="op">=</span> (df_EC_filtered[<span class="st">'Mx'</span>]<span class="op">+</span>z_0<span class="op">*</span>df_EC_filtered[<span class="st">'Fy'</span>])<span class="op">/</span>df_EC_filtered[<span class="st">'Fz'</span>]</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>COPy_EC <span class="op">=</span> (df_EC_filtered[<span class="st">'My'</span>]<span class="op">-</span>z_0<span class="op">*</span>df_EC_filtered[<span class="st">'Fx'</span>])<span class="op">/</span>df_EC_filtered[<span class="st">'Fz'</span>]</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>COPx_EO_centered <span class="op">=</span> (COPx_EO <span class="op">-</span> COPx_EO.mean())<span class="op">*</span><span class="fl">1e3</span> <span class="co"># Convert to mm</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>COPy_EO_centered <span class="op">=</span> (COPy_EO <span class="op">-</span> COPy_EO.mean())<span class="op">*</span><span class="fl">1e3</span> <span class="co"># Convert to mm</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>COPx_EC_centered <span class="op">=</span> (COPx_EC <span class="op">-</span> COPx_EC.mean())<span class="op">*</span><span class="fl">1e3</span> <span class="co"># Convert to mm</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>COPy_EC_centered <span class="op">=</span> (COPy_EC <span class="op">-</span> COPy_EC.mean())<span class="op">*</span><span class="fl">1e3</span> <span class="co"># Convert to mm</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, dpi<span class="op">=</span><span class="dv">100</span>, figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">6</span>))</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Determine the maximum range for centering around (0,0)</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>x_max <span class="op">=</span> np.ceil(<span class="fl">1.25</span><span class="op">*</span><span class="bu">max</span>(<span class="bu">abs</span>(COPx_EO_centered.<span class="bu">min</span>()), <span class="bu">abs</span>(COPx_EO_centered.<span class="bu">max</span>()),</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">abs</span>(COPx_EC_centered.<span class="bu">min</span>()), <span class="bu">abs</span>(COPx_EC_centered.<span class="bu">max</span>())))</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>y_max <span class="op">=</span> np.ceil(<span class="fl">1.25</span><span class="op">*</span><span class="bu">max</span>(<span class="bu">abs</span>(COPy_EO_centered.<span class="bu">min</span>()), <span class="bu">abs</span>(COPy_EO_centered.<span class="bu">max</span>()),</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>            <span class="bu">abs</span>(COPy_EC_centered.<span class="bu">min</span>()), <span class="bu">abs</span>(COPy_EC_centered.<span class="bu">max</span>())))</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>max_range <span class="op">=</span> <span class="bu">max</span>(x_max, y_max)  <span class="co"># Ensure square limits</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="co"># First subplot (EO)</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(COPx_EO_centered, COPy_EO_centered, color<span class="op">=</span><span class="st">'tab:blue'</span>, label<span class="op">=</span><span class="st">'EO'</span>)</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlabel(<span class="st">'Medial/lateral CoP position [mm]'</span>)</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylabel(<span class="st">'Anterior/posterior CoP position [mm]'</span>)</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">'Eyes Open Condition'</span>)</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_aspect(<span class="st">'equal'</span>)  <span class="co"># Ensures square aspect ratio</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Second subplot (EC)</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].plot(COPx_EC_centered, COPy_EC_centered, color<span class="op">=</span><span class="st">'tab:orange'</span>, label<span class="op">=</span><span class="st">'EC'</span>)</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylim(<span class="op">-</span>max_range, max_range)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlabel(<span class="st">'Medial/lateral CoP position [mm]'</span>)</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylabel(<span class="st">'Anterior/posterior CoP position [mm]'</span>)</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="st">'Eyes Closed Condition'</span>)</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].axvline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, linewidth<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_aspect(<span class="st">'equal'</span>)  <span class="co"># Ensures square aspect ratio</span></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Set overall figure title with large font</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">'Stabilogram Comparison'</span>, fontsize<span class="op">=</span><span class="dv">18</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(rect<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.95</span>])  <span class="co"># Adjust layout to fit the title</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="BalanceSignalProcessingTutorial_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="balance-metrics-definitions-computation-and-interpretation" class="level2">
<h2 class="anchored" data-anchor-id="balance-metrics-definitions-computation-and-interpretation">Balance metrics — definitions, computation, and interpretation</h2>
<p>This section computes commonly used scalar summary metrics from CoP time series and explains how to interpret them in the context of balance tasks.</p>
<p>Metrics computed in the notebook - AP excursion range: max(CoP_x) - min(CoP_x) (mm) - ML excursion range: max(CoP_y) - min(CoP_y) (mm) - Average CoP speed: mean( sqrt( (dx/dt)^2 + (dy/dt)^2 ) ) (mm/s) - Mean excursion distance: mean( sqrt(x^2 + y^2) ) (mm) - Std dev of excursion distance: std( sqrt(x^2 + y^2) ) (mm)</p>
<p>Implementation notes - Use centered CoP (subtract temporal mean) so offsets do not inflate range measures. - Compute derivatives using successive differences divided by dt (ensure consistent units: mm vs m). - For average speed, ignore NaN or masked samples (e.g., where Fz was invalid). Consider thresholding small Fz values before computing CoP. - Document sampling rate, filter design (type, order, cutoff) and any NaN handling — metrics are sensitive to filtering and preprocessing.</p>
<p>How to interpret each metric (practical guide) - AP / ML excursion ranges - What they measure: trial-wide span of CoP in anterior–posterior and medial–lateral axes. - Larger values → greater gross excursion (more sway or larger shifts of load). Directional changes (AP vs ML) can indicate task-specific instability (e.g., tandem stance increases AP). - Caveats: ranges are sensitive to brief large transients (artifacts). Check stabilograms to confirm excursions reflect behaviour, not noise. - Average CoP speed - What it measures: time-averaged instantaneous CoP velocity; captures how actively the subject is correcting posture. - Larger speed → more frequent/rapid corrective actions or noise. Often more sensitive to subtle balance changes than range. - Caveats: speed increases with trial length variability and with higher-frequency noise; ensure consistent filtering across conditions. - Mean excursion distance - What it measures: average radial distance from center (magnitude of sway). - Larger mean distance → CoP is on average farther from center; useful summary of overall displacement. - Complement with range and speed to distinguish broad drift vs frequent small corrections. - Std dev of excursion distance - What it measures: variability of radial CoP magnitude; indicates consistency vs intermittency of sway. - Larger std → more variable control (bursty corrections or inconsistent posture).</p>
<p>Practical interpretation rules of thumb - Compare within-subject, within-task (paired comparisons) whenever possible; absolute values depend on posture, footwear, surface, and trial duration. - Use percent change and paired statistics (paired t-test, Wilcoxon) for EO vs EC or pre/post designs — report effect size and confidence intervals, not only p-values. - Visual checks: always inspect stabilograms (trajectory) and raw vs filtered traces to ensure metrics reflect behavior. - Filtering matters: a more aggressive low-pass reduces speed and high-frequency variance while leaving gross ranges less affected. Report filter parameters.</p>
<p>Handling artifacts and edge cases - Outliers: remove or clip transient spikes before computing range/speed. - Low/zero Fz: mask samples where Fz is near zero (division instability) or interpolate short gaps. - Short trials: filtfilt padding may fail and introduce phase shift; avoid phase-sensitive metrics if lfilter fallback occurs.</p>
<div id="cf89d066" class="cell" data-execution_count="87">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>fs <span class="co"># Time difference between adjacent time points</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co"># AP (Anterior-Posterior) Excursion Range</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>AP_EO <span class="op">=</span> COPx_EO_centered.<span class="bu">max</span>() <span class="op">-</span> COPx_EO_centered.<span class="bu">min</span>()</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>AP_EC <span class="op">=</span> COPx_EC_centered.<span class="bu">max</span>() <span class="op">-</span> COPx_EC_centered.<span class="bu">min</span>()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ML (Medio-Lateral) Excursion Range</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>ML_EO <span class="op">=</span> COPy_EO_centered.<span class="bu">max</span>() <span class="op">-</span> COPy_EO_centered.<span class="bu">min</span>()</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>ML_EC <span class="op">=</span> COPy_EC_centered.<span class="bu">max</span>() <span class="op">-</span> COPy_EC_centered.<span class="bu">min</span>()</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Average CoP Speed</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>Avg_CoP_Speed_EO <span class="op">=</span> (np.sqrt(COPx_EO_centered.diff()<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> COPy_EO_centered.diff()<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span>dt).mean()</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>Avg_CoP_Speed_EC <span class="op">=</span> (np.sqrt(COPx_EC_centered.diff()<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> COPy_EC_centered.diff()<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span>dt).mean()</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Mean Excursion Distance</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>Mean_Excursion_Distance_EO <span class="op">=</span> np.sqrt(COPx_EO_centered<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> COPy_EO_centered<span class="op">**</span><span class="dv">2</span>).mean()</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>Mean_Excursion_Distance_EC <span class="op">=</span> np.sqrt(COPx_EC_centered<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> COPy_EC_centered<span class="op">**</span><span class="dv">2</span>).mean()</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard Deviation of Excursion Distance</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>StDev_Excursion_Distance_EO <span class="op">=</span> np.sqrt(COPx_EO_centered<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> COPy_EO_centered<span class="op">**</span><span class="dv">2</span>).std()</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>StDev_Excursion_Distance_EC <span class="op">=</span> np.sqrt(COPx_EC_centered<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> COPy_EC_centered<span class="op">**</span><span class="dv">2</span>).std()</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the calculated metrics</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Eyes Open Condition:"</span>)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"AP Excursion Range: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(AP_EO))</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ML Excursion Range: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(ML_EO))</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Average CoP Speed: </span><span class="sc">{:.2f}</span><span class="st"> mm/s"</span>.<span class="bu">format</span>(Avg_CoP_Speed_EO))</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Mean Excursion Distance: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(Mean_Excursion_Distance_EO))</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Standard Deviation of Excursion Distance: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(StDev_Excursion_Distance_EO))</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Eyes Closed Condition:"</span>)</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"AP Excursion Range: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(AP_EC))</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ML Excursion Range: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(ML_EC))</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Average CoP Speed: </span><span class="sc">{:.2f}</span><span class="st"> mm/s"</span>.<span class="bu">format</span>(Avg_CoP_Speed_EC))</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Mean Excursion Distance: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(Mean_Excursion_Distance_EC))</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Standard Deviation of Excursion Distance: </span><span class="sc">{:.2f}</span><span class="st"> mm"</span>.<span class="bu">format</span>(StDev_Excursion_Distance_EC))</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Percent change using (EC - EO) / EO * 100</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>AP_percent_change <span class="op">=</span> (AP_EC <span class="op">-</span> AP_EO) <span class="op">/</span> AP_EO <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>ML_percent_change <span class="op">=</span> (ML_EC <span class="op">-</span> ML_EO) <span class="op">/</span> ML_EO <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>Avg_CoP_Speed_percent_change <span class="op">=</span> (Avg_CoP_Speed_EC <span class="op">-</span> Avg_CoP_Speed_EO) <span class="op">/</span> Avg_CoP_Speed_EO <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>Mean_Excursion_Distance_percent_change <span class="op">=</span> (Mean_Excursion_Distance_EC <span class="op">-</span> Mean_Excursion_Distance_EO) <span class="op">/</span> Mean_Excursion_Distance_EO <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>StDev_Excursion_Distance_percent_change <span class="op">=</span> (StDev_Excursion_Distance_EC <span class="op">-</span> StDev_Excursion_Distance_EO) <span class="op">/</span> StDev_Excursion_Distance_EO <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the percent differences</span></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Percent change from Eyes Open to Eyes Closed conditions:"</span>)</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"AP Excursion Range: </span><span class="sc">{:+.2f}</span><span class="st"> %"</span>.<span class="bu">format</span>(AP_percent_change))</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"ML Excursion Range: </span><span class="sc">{:+.2f}</span><span class="st"> %"</span>.<span class="bu">format</span>(ML_percent_change))</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Average CoP Speed: </span><span class="sc">{:+.2f}</span><span class="st"> %"</span>.<span class="bu">format</span>(Avg_CoP_Speed_percent_change))</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Mean Excursion Distance: </span><span class="sc">{:+.2f}</span><span class="st"> %"</span>.<span class="bu">format</span>(Mean_Excursion_Distance_percent_change))</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Standard Deviation of Excursion Distance: </span><span class="sc">{:+.2f}</span><span class="st"> %"</span>.<span class="bu">format</span>(StDev_Excursion_Distance_percent_change))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Eyes Open Condition:
AP Excursion Range: 25.84 mm
ML Excursion Range: 25.82 mm
Average CoP Speed: 29.84 mm/s
Mean Excursion Distance: 6.92 mm
Standard Deviation of Excursion Distance: 3.72 mm

Eyes Closed Condition:
AP Excursion Range: 26.63 mm
ML Excursion Range: 32.95 mm
Average CoP Speed: 53.20 mm/s
Mean Excursion Distance: 7.36 mm
Standard Deviation of Excursion Distance: 3.70 mm

Percent change from Eyes Open to Eyes Closed conditions:
AP Excursion Range: +3.08 %
ML Excursion Range: +27.60 %
Average CoP Speed: +78.31 %
Mean Excursion Distance: +6.33 %
Standard Deviation of Excursion Distance: -0.64 %</code></pre>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>